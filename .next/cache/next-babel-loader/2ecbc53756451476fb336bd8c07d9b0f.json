{"ast":null,"code":"import _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { Room, Node } from './room';\n\nvar Map =\n/*#__PURE__*/\nfunction () {\n  //map will work most of the times, however, doesn't check every position \n  function Map(boardWidth, boardlength) {\n    _classCallCheck(this, Map);\n\n    //describes the boards with relative to amount of squares\n    this.width = boardWidth;\n    this.height = boardlength;\n    this.clearedBoard = [];\n    this.removedHalls = []; //initialize the board with a clear state\n\n    this.clear();\n    this.board = this.clearedBoard;\n    this.roomCounter = 8;\n    this.createRooms(this.roomCounter);\n  }\n\n  _createClass(Map, [{\n    key: \"clear\",\n    value: function clear() {\n      for (var i = 0; i < this.height; i++) {\n        var arr = [];\n\n        for (var j = 0; j < this.width; j++) {\n          var emptyNodes = new Node('-', [i, j]);\n          arr.push(emptyNodes);\n        }\n\n        this.clearedBoard.push(arr);\n      }\n    }\n  }, {\n    key: \"createRooms\",\n    value: function createRooms(roomNumber) {\n      var roomCount = roomNumber;\n      var randomSize = [5, 7];\n      var roomNode = new Room(randomSize[0], randomSize[1]); // //create some halls\n\n      var halls = this.generateHalls(2); //initialize queue\n\n      var position = [30, 40];\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        roomNode.buildCooridor(halls[i]);\n      }\n\n      roomNode.changePosition(position);\n      roomNode.visited = true;\n      this.placeRoom(roomNode);\n      var queue = [];\n      queue.push(roomNode);\n      var randomCount = 8;\n\n      while (queue.length) {\n        var node = queue.shift(0);\n\n        if (node) {\n          var rooms = this.generateRooms(node);\n\n          for (var i = 0; i < rooms.length; i++) {\n            this.placeRoom(rooms[i]);\n            queue.push(rooms[i]);\n          }\n        }\n      }\n\n      for (var i = 0; i < this.removedHalls.length; i++) {\n        var row = this.removedHalls[i].position[0];\n        var col = this.removedHalls[i].position[1];\n\n        if (this.board[row][col].type == 'H') {\n          this.board[row][col] = this.removedHalls[i];\n        }\n      }\n    } //methods for the right\n\n  }, {\n    key: \"rightColPositions\",\n    value: function rightColPositions(callback) {\n      var colSpan = arguments[0];\n      var rowIdx = arguments[1];\n      var board = arguments[2];\n      var l = colSpan[0];\n      var r = colSpan[1];\n      var span = Math.abs(l - r); //checks mid as an extra check\n\n      var m = r + Math.floor(span / 2);\n      var counter = 0;\n\n      try {\n        if (board[rowIdx][l + 1].filled == true) {\n          return null;\n        } else if (board[rowIdx][m].filled == true) {\n          return null;\n        } else if (board[rowIdx][r].filled == false) {\n          return [l, r];\n        } else {\n          while (board[rowIdx][r].filled == true && counter < 3 && span > 3) {\n            //reduce r by a quarter of current span each time\n            // console.log('reducing')\n            r = r - Math.floor(span / 4);\n\n            if (board[rowIdx][r].filled == false) {\n              return [l, r];\n            }\n\n            span = Math.abs(l - r);\n            counter += 1;\n          }\n        }\n      } catch (e) {\n        console.log('column position is null with', l, r);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"rightRowPositions\",\n    value: function rightRowPositions(callback) {\n      var rowSpan = arguments[0];\n      var colIdx = arguments[1] + 1; //get offset so not looking at hall\n\n      var board = arguments[2]; //get top and bottom\n\n      var t = rowSpan[0];\n      var b = rowSpan[1]; //create copies to check reduction bounds\n\n      var originalT = t; //counter for a quit if the room cannot be created with the max amount of tries\n\n      var counter = 0;\n      var span = Math.abs(t - b); //reduce by more than a half because of offsets\n\n      t = t - Math.floor(span / 4);\n      b = b - Math.floor(span / 4); //update the span\n\n      span = Math.abs(t - b);\n      var m = t + Math.floor(span / 2);\n\n      try {\n        //if nothing has to be done return the positions as is\n        if (board[m][colIdx].filled == true) {\n          return null;\n        } else if (board[t][colIdx].filled == false && board[b][colIdx].filled == false && //checks if the board is filled there\n        board[t][colIdx - 1].type !== 'H' && board[b][colIdx - 1] !== 'H') {\n          //checks the bounds to make sure hall is not in the empty spaces\n          // console.log('returning original')\n          return [t, b];\n        } else {\n          while ((board[t][colIdx].filled == true || board[b][colIdx].filled == true || board[t][colIdx - 1].type !== 'H' || board[b][colIdx - 1].type !== 'H') && counter < 3 && span > 3) {\n            // console.log('reducing')\n            //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\n            if (board[t][colIdx].filled == true) {\n              t = t + Math.floor(span / 4);\n            } //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\n\n\n            if (board[b][colIdx].filled == true) {\n              b = b - Math.floor(span / 4);\n            } //return the updated positions if the positions are not filled\n\n\n            if (board[t][colIdx].filled == false && board[b][colIdx].filled == false && originalT >= t && t < b && span > 3) {\n              return [t, b];\n            } //update the span\n\n\n            span = Math.abs(t - b); //update counter\n\n            counter += 1;\n          }\n        }\n      } catch (e) {\n        console.log('row position is null with top:${t} and bottom: ${b}');\n        return null;\n      }\n\n      return null;\n    } //methods for the left\n\n  }, {\n    key: \"leftColPositions\",\n    value: function leftColPositions(callback) {\n      var colSpan = arguments[0];\n      var rowIdx = arguments[1];\n      var board = arguments[2];\n      var l = colSpan[0]; //l would be what would change\n\n      var r = colSpan[1]; //r would be the starting position\n\n      var counter = 0;\n      var span = Math.abs(l - r);\n      var m = l + Math.floor(span / 2);\n\n      try {\n        if (board[rowIdx][m].filled == true) {\n          return null;\n        } else if (board[rowIdx][r - 2].type == 'H') {\n          return null;\n        } else if (board[rowIdx][l].filled == false) {\n          return [l, r];\n        } else {\n          while (board[rowIdx][l].filled == true && counter < 3 && span > 3) {\n            //reduce l by a quarter of current span each time\n            l = l + Math.floor(span / 4);\n\n            if (board[rowIdx][l].filled == false && span > 3) {\n              return [l, r];\n            }\n\n            span = Math.abs(l - r);\n            counter += 1;\n          }\n        }\n      } catch (e) {\n        console.log('column position is null with', l, r);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"leftRowPositions\",\n    value: function leftRowPositions(callback) {\n      var rowSpan = arguments[0];\n      var colIdx = arguments[1] - 1; //get offset so not looking at hall\n\n      var board = arguments[2]; //get top and bottom\n\n      var t = rowSpan[0];\n      var b = rowSpan[1]; //create copies to check reduction bounds\n\n      var originalT = t; //counter for a quit if the room cannot be created with the max amount of tries\n\n      var counter = 0;\n      var span = Math.abs(t - b); //reduce by more than a half because of offsets\n\n      t = t - Math.floor(span / 3);\n      b = b - Math.floor(span / 3); //update the span\n\n      span = Math.abs(t - b);\n      var m = t + Math.floor(span / 2);\n\n      try {\n        //if nothing has to be done return the positions as is\n        if (board[m][colIdx].filled == true) {\n          return null;\n        } else if (board[t][colIdx].filled == true) {\n          return null;\n        } else if (board[t][colIdx].filled == false && board[b][colIdx].filled == false) {\n          //checks the bounds to make sure hall is not in the empty spaces\n          // console.log('returning original')\n          return [t, b];\n        } else {\n          while ((board[t][colIdx].filled == true || board[b][colIdx].filled == true || board[t][colIdx + 1].type !== 'H' || board[b][colIdx + 1].type !== 'H') && counter < 3 && span > 3) {\n            //console.log('reducing')\n            //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\n            if (board[t][colIdx].filled == true) {\n              t = t + Math.floor(span / 4);\n            } //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\n\n\n            if (board[b][colIdx].filled == true) {\n              b = b - Math.floor(span / 4);\n            } //return the updated positions if the positions are not filled\n\n\n            if (board[t][colIdx].filled == false && board[b][colIdx].filled == false && originalT >= t && t < b && span > 3) {\n              return [t, b];\n            } //update the span\n\n\n            span = Math.abs(t - b); //update counter\n\n            counter += 1;\n          }\n        }\n      } catch (e) {\n        console.log('row position is null with top:${t} and bottom: ${b}');\n        return null;\n      }\n\n      return null;\n    } //methods for the top\n\n  }, {\n    key: \"topColPositions\",\n    value: function topColPositions(callback) {\n      var colSpan = arguments[0];\n      var rowIdx = arguments[1] - 1; //get offset so not looking at hall\n\n      var board = arguments[2]; //get top and bottom\n\n      var l = colSpan[0];\n      var r = colSpan[1]; //create copies to check reduction bounds\n\n      var originalL = l; //counter for a quit if the room cannot be created with the max amount of tries\n\n      var counter = 0;\n      var span = Math.abs(l - r); //reduce by more than a half because of offsets\n\n      l = l - Math.floor(span / 3);\n      r = r - Math.floor(span / 3); //update the span\n\n      span = Math.abs(l - r);\n\n      try {\n        if (board[rowIdx][l].filled == false && board[rowIdx][r].filled == false) {\n          //checks the bounds to make sure hall is not in the empty spaces\n          // console.log('returning original')\n          return [l, r];\n        } else {\n          while ((board[l][rowIdx].filled == true || board[r][rowIdx].filled == true || board[rowIdx + 1][l].type !== 'H' || board[rowIdx + 1][r].type !== 'H') && counter < 3 && span > 3) {\n            // console.log('reducing')\n            //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\n            if (board[rowIdx][l].filled == true) {\n              l = l + Math.floor(span / 4);\n            } //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\n\n\n            if (board[rowIdx][r].filled == true) {\n              r = r - Math.floor(span / 4);\n            } //return the updated positions if the positions are not filled\n\n\n            if (board[rowIdx][l].filled == false && board[rowIdx][r].filled == false && originalL >= l && l < r && span > 3) {\n              return [l, r];\n            } //update the span\n\n\n            span = Math.abs(l - r); //update counter\n\n            counter += 1;\n          }\n        }\n      } catch (e) {\n        console.log('row position is null with top:${t} and bottom: ${b}');\n        return null;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"topRowPositions\",\n    value: function topRowPositions(callback) {\n      var rowSpan = arguments[0];\n      var colIdx = arguments[1];\n      var board = arguments[2];\n      var t = rowSpan[0]; //l would be what would change\n\n      var b = rowSpan[1]; //r would be the starting position\n\n      var counter = 0;\n      var span = Math.abs(t - b);\n\n      try {\n        if (board[b - 2][colIdx].filled == true) {\n          return null;\n        } else if (board[t][colIdx].filled == false) {\n          return [t, b];\n        } else {\n          while (board[t][colIdx].filled == true && counter < 3 && span > 3) {\n            // console.log('reducing')\n            //reduce l by a quarter of current span each time\n            t = t + Math.floor(span / 4);\n\n            if (board[t][colIdx].filled == false && span > 3) {\n              return [t, b];\n            }\n\n            span = Math.abs(t - b);\n            counter += 1;\n          }\n        }\n      } catch (e) {\n        console.log('column position is null with', t, b);\n        return null;\n      }\n\n      return null;\n    } //methods for the bottom\n\n  }, {\n    key: \"botColPositions\",\n    value: function botColPositions(callback) {\n      var colSpan = arguments[0];\n      var rowIdx = arguments[1] + 1; //get offset so not looking at hall\n\n      var board = arguments[2]; //get top and bottom\n\n      var l = colSpan[0];\n      var r = colSpan[1]; //create copies to check reduction bounds\n\n      var originalL = l; //counter for a quit if the room cannot be created with the max amount of tries\n\n      var counter = 0;\n      var span = Math.abs(l - r); //reduce by more than a half because of offsets\n\n      l = l - Math.floor(span / 4);\n      r = r - Math.floor(span / 4); //update the span\n\n      span = Math.abs(l - r);\n      var m = l + Math.floor(span / 2);\n\n      try {\n        //if nothing has to be done return the positions as is\n        if (board[rowIdx][m].filled == true) {\n          return null;\n        } else if (board[rowIdx][l].filled == false && board[rowIdx][r].filled == false && board[rowIdx - 1][l].filled == false && board[rowIdx - 1][r].filled == false) {\n          //checks the bounds to make sure hall is not in the empty spaces\n          // console.log('returning original')\n          return [l, r];\n        } else {\n          while ((board[l][rowIdx].filled == true || board[r][rowIdx].filled == true || board[rowIdx - 1][l].type !== 'H' || board[rowIdx - 1][r].type !== 'H') && counter < 3 && span > 3) {\n            // console.log('reducing')\n            //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\n            if (board[rowIdx][l].filled == true) {\n              l = l + Math.floor(span / 4);\n            } //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\n\n\n            if (board[rowIdx][r].filled == true) {\n              r = r - Math.floor(span / 4);\n            } //return the updated positions if the positions are not filled\n\n\n            if (board[rowIdx][l].filled == false && board[rowIdx][r].filled == false && originalL >= l && l < r && span > 3) {\n              return [l, r];\n            } //update the span\n\n\n            span = Math.abs(l - r); //update counter\n\n            counter += 1;\n          }\n        }\n      } catch (e) {\n        console.log('row position is null with top:${t} and bottom: ${b}');\n        return null;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"botRowPositions\",\n    value: function botRowPositions(callback) {\n      var rowSpan = arguments[0];\n      var colIdx = arguments[1];\n      var board = arguments[2];\n      var t = rowSpan[0]; //l would be what would change\n\n      var b = rowSpan[1]; //r would be the starting position\n\n      var counter = 0;\n      var span = Math.abs(t - b);\n      var m = t + Math.floor(span / 2);\n\n      try {\n        if (board[m][colIdx].filled == true) {\n          return null;\n        }\n\n        if (board[t + 1][colIdx].filled == true) {\n          return null;\n        } else if (board[b][colIdx].filled == false) {\n          return [t, b];\n        } else {\n          while (board[b][colIdx].filled == true && counter < 3 && span > 3) {\n            // console.log('reducing')\n            //reduce l by a quarter of current span each time\n            b = b - Math.floor(span / 4);\n\n            if (board[b][colIdx].filled == false && span > 3) {\n              return [t, b];\n            }\n\n            span = Math.abs(t - b);\n            counter += 1;\n          }\n        }\n      } catch (e) {\n        console.log('column position is null with', t, b);\n        return null;\n      }\n\n      return null;\n    } //goes to generateRoom for generateRooms()\n\n  }, {\n    key: \"generateRoom\",\n    value: function generateRoom(rowcallback, colcallback, rowSpan, colSpan, direction) {\n      var board = this.board; //Generation of the rows and columns\n\n      var rowPosition = rowcallback(rowSpan, colSpan[0], board);\n      var colPosition = colcallback(colSpan, rowSpan[0], board);\n\n      if (rowPosition == null || colPosition == null) {\n        return null;\n      }\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]);\n\n      if (rowSize < 4 || colSize < 4) {\n        return null;\n      }\n\n      var position = [rowPosition[0], colPosition[0]];\n      var room = new Room(colSize, rowSize);\n      var halls = this.generateHalls(1);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == direction) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n      }\n\n      room.changePosition(position);\n      return room;\n    } //where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\n\n  }, {\n    key: \"generateRooms\",\n    value: function generateRooms(node) {\n      var halls = node.halls;\n      var len = halls.length;\n      var rooms = [];\n      var newRoom = null;\n      var removedHalls = [];\n\n      for (var i = 0; i < len; i++) {\n        var roomSize = this.randomSize(5, 7);\n        var rowStart = halls[i].position[0];\n        var colStart = halls[i].position[1];\n\n        switch (halls[i].direction) {\n          case 'r':\n            //the -1 is to offset the side on the top\n            var rowSpan = [rowStart - 1, rowStart + roomSize[0] - 1]; //dont need to offset the col because the hall connect what would be the blank space\n\n            var colSpan = [colStart, colStart + roomSize[1]];\n\n            try {\n              newRoom = this.generateRoom(this.rightRowPositions, this.rightColPositions, rowSpan, colSpan, 'l');\n\n              if (newRoom == null) {\n                removedHalls.push(halls[i]);\n                continue;\n              }\n\n              rooms.push(newRoom);\n            } catch (e) {\n              console.log('room is null');\n            }\n\n            break;\n\n          case 'l':\n            //the -1 is to offset the side on the top\n            var rowSpan = [rowStart - 1, rowStart + roomSize[0] - 1]; //dont need to offset the col because the hall connect what would be the blank space\n\n            var colSpan = [colStart - roomSize[1] + 1, colStart + 1];\n\n            try {\n              newRoom = this.generateRoom(this.leftRowPositions, this.leftColPositions, rowSpan, colSpan, 'r');\n\n              if (newRoom == null) {\n                removedHalls.push(halls[i]);\n                continue;\n              }\n\n              rooms.push(newRoom);\n            } catch (e) {\n              console.log('room is null');\n            }\n\n            break;\n\n          case 't':\n            // the -1 is to offset the side on the top\n            var rowSpan = [rowStart - roomSize[0] + 1, rowStart + 1]; //dont need to offset the col because the hall connect what would be the blank space\n\n            var colSpan = [colStart - 1, colStart + roomSize[1] - 1];\n\n            try {\n              newRoom = this.generateRoom(this.topRowPositions, this.topColPositions, rowSpan, colSpan, 'b');\n\n              if (newRoom == null) {\n                removedHalls.push(halls[i]);\n                continue;\n              }\n\n              rooms.push(newRoom);\n            } catch (e) {\n              console.log('room is null');\n            }\n\n            break;\n\n          case 'b':\n            //the -1 is to offset the side on the top\n            var rowSpan = [rowStart, rowStart + roomSize[0]]; //dont need to offset the col because the hall connect what would be the blank space\n\n            var colSpan = [colStart - 1, colStart + roomSize[1] - 1];\n\n            try {\n              newRoom = this.generateRoom(this.botRowPositions, this.botColPositions, rowSpan, colSpan, 't');\n\n              if (newRoom == null) {\n                removedHalls.push(halls[i]);\n                continue;\n              }\n\n              rooms.push(newRoom);\n            } catch (e) {\n              console.log('room is null');\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      for (var i = 0; i < removedHalls.length; i++) {\n        this.removedHalls.push(new Node('-', removedHalls[i].position));\n      }\n\n      return rooms;\n    }\n  }, {\n    key: \"generateHalls\",\n    value: function generateHalls(num) {\n      var hallDirections = ['l', 'r', 't', 'b'];\n      var randomDirs = [];\n      var counter = num;\n\n      while (counter > -1) {\n        var idx = Math.floor(Math.random() * hallDirections.length + 0);\n        randomDirs.push(hallDirections[idx]);\n        hallDirections.splice(idx, 1);\n        counter -= 1;\n      }\n\n      return randomDirs;\n    }\n  }, {\n    key: \"randomSize\",\n    value: function randomSize(min, max) {\n      var length = Math.floor(Math.random() * max + min);\n      var width = Math.floor(Math.random() * max + min);\n      var arr = [length, width];\n      return arr;\n    }\n  }, {\n    key: \"placeRoom\",\n    value: function placeRoom(room) {\n      //where position is based on row, col for map\n      var rowLength = room.width;\n      var colLength = room.height;\n\n      for (var i = 0; i < rowLength; i++) {\n        for (var j = 0; j < colLength; j++) {\n          var row = room.contents[i][j].position[0];\n          var col = room.contents[i][j].position[1];\n\n          if (this.board[row][col].type !== 'H' && this.board[row][col].filled == false) {\n            this.board[row][col] = room.contents[i][j];\n            this.board[row][col].filled = true;\n          } //this will combine the rooms into one bigger room\n          else if ((this.board[row][col].type === 'X' || this.board[row][col].type === 'C' || this.board[row][col].type === 'H') && room.contents[i][j].type == 'L') {\n              this.board[row][col] = room.contents[i][j];\n              this.board[row][col].filled = true;\n            }\n        }\n      }\n    }\n  }, {\n    key: \"contents\",\n    get: function get() {\n      return this.board;\n    }\n  }]);\n\n  return Map;\n}();\n\nexport default Map;","map":{"version":3,"sources":["D:\\Programming\\Dungeon Crawler\\pages\\map.js"],"names":["Room","Node","Map","boardWidth","boardlength","width","height","clearedBoard","removedHalls","clear","board","roomCounter","createRooms","i","arr","j","emptyNodes","push","roomNumber","roomCount","randomSize","roomNode","halls","generateHalls","position","length","buildCooridor","changePosition","visited","placeRoom","queue","randomCount","node","shift","rooms","generateRooms","row","col","type","callback","colSpan","arguments","rowIdx","l","r","span","Math","abs","m","floor","counter","filled","e","console","log","rowSpan","colIdx","t","b","originalT","originalL","rowcallback","colcallback","direction","rowPosition","colPosition","rowSize","colSize","room","len","newRoom","roomSize","rowStart","colStart","generateRoom","rightRowPositions","rightColPositions","leftRowPositions","leftColPositions","topRowPositions","topColPositions","botRowPositions","botColPositions","num","hallDirections","randomDirs","idx","random","splice","min","max","rowLength","colLength","contents"],"mappings":"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","sourcesContent":["import {Room, Node} from './room'\r\n\r\nclass Map{\r\n    //map will work most of the times, however, doesn't check every position \r\n    constructor(boardWidth, boardlength){\r\n        //describes the boards with relative to amount of squares\r\n        this.width = boardWidth;\r\n        this.height = boardlength;\r\n        this.clearedBoard = [];\r\n        this.removedHalls = [];\r\n        //initialize the board with a clear state\r\n        this.clear()\r\n        this.board = this.clearedBoard\r\n        this.roomCounter = 8\r\n        this.createRooms(this.roomCounter)\r\n    }\r\n\r\n    clear(){\r\n        for(var i = 0; i < this.height; i++){\r\n            let arr = []\r\n            for(var j = 0; j < this.width; j++){\r\n                var emptyNodes = new Node('-', [i,j])\r\n                arr.push(emptyNodes)\r\n            }\r\n            this.clearedBoard.push(arr)\r\n        }\r\n    }\r\n    \r\n    createRooms(roomNumber){\r\n\r\n        var roomCount = roomNumber\r\n        var randomSize = [5,7]\r\n        var roomNode = new Room(randomSize[0], randomSize[1])\r\n        // //create some halls\r\n        var halls = this.generateHalls(2)\r\n        //initialize queue\r\n        var position = [30,40]\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            roomNode.buildCooridor(halls[i])\r\n        }\r\n        roomNode.changePosition(position)\r\n        roomNode.visited = true\r\n\r\n        this.placeRoom(roomNode)\r\n\r\n        var queue = []\r\n        queue.push(roomNode)\r\n        var randomCount = 8\r\n        while(queue.length ){\r\n            var node = queue.shift(0)\r\n            if(node)\r\n            {\r\n                var rooms = this.generateRooms(node)\r\n                for(var i = 0; i < rooms.length; i++){\r\n                    this.placeRoom(rooms[i])\r\n                    queue.push(rooms[i])\r\n                }\r\n            }\r\n            \r\n        }\r\n        for(var i = 0; i < this.removedHalls.length; i++){\r\n            var row = this.removedHalls[i].position[0]\r\n            var col = this.removedHalls[i].position[1]\r\n            if(this.board[row][col].type == 'H'){\r\n                this.board[row][col] = this.removedHalls[i]\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n//methods for the right\r\n    rightColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n        var span = Math.abs(l-r)\r\n        //checks mid as an extra check\r\n        var m = r + Math.floor(span/2)\r\n        var counter = 0\r\n        try{\r\n            if(board[rowIdx][l+1].filled == true){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][m].filled == true){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][r].filled == false){\r\n                return [l,r]\r\n            }\r\n            else{\r\n                while(board[rowIdx][r].filled == true && counter < 3 && span > 3){\r\n                    //reduce r by a quarter of current span each time\r\n                    // console.log('reducing')\r\n                    r = r - Math.floor(span/4)\r\n                    if(board[rowIdx][r].filled == false){\r\n                        return [l,r]\r\n                    }\r\n                    span = Math.abs(l-r)\r\n                    counter += 1\r\n                }\r\n            }\r\n        }\r\n        catch(e){\r\n            console.log('column position is null with',l,r)\r\n        }\r\n        return null\r\n    }\r\n    rightRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1] + 1//get offset so not looking at hall\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var t = rowSpan[0]\r\n        var b = rowSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalT = t\r\n        //counter for a quit if the room cannot be created with the max amount of tries\r\n        var counter = 0\r\n\r\n        var span = Math.abs(t-b)\r\n        //reduce by more than a half because of offsets\r\n        t = t - Math.floor((span/4))\r\n        b = b - Math.floor(span/4)\r\n        //update the span\r\n        span = Math.abs(t - b)\r\n        var m = t + Math.floor(span/2)\r\n        try{\r\n            //if nothing has to be done return the positions as is\r\n            if(board[m][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if(board[t][colIdx].filled == false && board[b][colIdx].filled == false &&//checks if the board is filled there\r\n                board[t][colIdx-1].type !== 'H' && board[b][colIdx-1] !== 'H'){//checks the bounds to make sure hall is not in the empty spaces\r\n                // console.log('returning original')\r\n                return [t,b]\r\n            }\r\n            else{\r\n                while(((board[t][colIdx].filled == true || board[b][colIdx].filled == true) ||\r\n                      (board[t][colIdx-1].type !== 'H' || board[b][colIdx-1].type !== 'H')) && \r\n                      counter < 3 && span > 3){\r\n                    // console.log('reducing')\r\n                    //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[t][colIdx].filled == true){\r\n                        t = t + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[b][colIdx].filled == true){\r\n                        b = b - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[t][colIdx].filled == false && board[b][colIdx].filled == false && originalT >= t && t < b && span > 3){\r\n                        return [t,b]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(t-b)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n\r\n//methods for the left\r\n    leftColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var l = colSpan[0]//l would be what would change\r\n        var r = colSpan[1]//r would be the starting position\r\n        var counter = 0\r\n        var span = Math.abs(l-r)\r\n        var m = l + Math.floor(span/2)\r\n\r\n        try{\r\n            if(board[rowIdx][m].filled == true){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][r-2].type == 'H'){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][l].filled == false){\r\n                return [l,r]\r\n            }\r\n            else{\r\n                while(board[rowIdx][l].filled == true && counter < 3 && span > 3){\r\n                    //reduce l by a quarter of current span each time\r\n                    l = l + Math.floor(span/4)\r\n                    if(board[rowIdx][l].filled == false && span > 3){\r\n                        return [l,r]\r\n                    }\r\n                    span = Math.abs(l-r)\r\n                    counter += 1\r\n                }\r\n            }\r\n        }\r\n        catch(e){\r\n            console.log('column position is null with',l,r)\r\n        }\r\n        return null\r\n    }\r\n\r\n    leftRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1] - 1//get offset so not looking at hall\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var t = rowSpan[0]\r\n        var b = rowSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalT = t\r\n        //counter for a quit if the room cannot be created with the max amount of tries\r\n        var counter = 0\r\n\r\n        var span = Math.abs(t-b)\r\n        //reduce by more than a half because of offsets\r\n        t = t - Math.floor((span/3))\r\n        b = b - Math.floor(span/3)\r\n        //update the span\r\n        span = Math.abs(t - b)\r\n        var m = t + Math.floor(span/2)\r\n        try{\r\n            //if nothing has to be done return the positions as is\r\n            if(board[m][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if(board[t][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if(board[t][colIdx].filled == false && board[b][colIdx].filled == false){//checks the bounds to make sure hall is not in the empty spaces\r\n                // console.log('returning original')\r\n                return [t,b]\r\n            }\r\n            else{\r\n                while(((board[t][colIdx].filled == true || board[b][colIdx].filled == true) ||\r\n                      (board[t][colIdx+1].type !== 'H' || board[b][colIdx+1].type !== 'H')) && \r\n                      counter < 3 && span > 3){\r\n                    //console.log('reducing')\r\n                    //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[t][colIdx].filled == true){\r\n                        t = t + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[b][colIdx].filled == true){\r\n                        b = b - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[t][colIdx].filled == false && board[b][colIdx].filled == false && originalT >= t && t < b && span > 3){\r\n                        return [t,b]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(t-b)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n\r\n//methods for the top\r\n    topColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1] - 1//get offset so not looking at hall\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalL = l\r\n        //counter for a quit if the room cannot be created with the max amount of tries\r\n        var counter = 0\r\n\r\n        var span = Math.abs(l-r)\r\n        //reduce by more than a half because of offsets\r\n        l = l - Math.floor((span/3))\r\n        r = r - Math.floor(span/3)\r\n        //update the span\r\n        span = Math.abs(l - r)\r\n        try{\r\n            if(board[rowIdx][l].filled == false && board[rowIdx][r].filled == false){//checks the bounds to make sure hall is not in the empty spaces\r\n                // console.log('returning original')\r\n                return [l,r]\r\n            }\r\n            else{\r\n                while(((board[l][rowIdx].filled == true || board[r][rowIdx].filled == true) ||\r\n                      (board[rowIdx+1][l].type !== 'H' || board[rowIdx+1][r].type !== 'H')) && \r\n                      counter < 3 && span > 3){\r\n                    // console.log('reducing')\r\n                    //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[rowIdx][l].filled == true){\r\n                        l = l + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[rowIdx][r].filled == true){\r\n                        r = r - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[rowIdx][l].filled == false && board[rowIdx][r].filled == false && originalL >= l && l < r && span > 3){\r\n                        return [l,r]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(l-r)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n    topRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var t = rowSpan[0]//l would be what would change\r\n        var b = rowSpan[1]//r would be the starting position\r\n        var counter = 0\r\n        var span = Math.abs(t-b)\r\n        try {\r\n            if(board[b-2][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if (board[t][colIdx].filled == false) {\r\n                return [t, b]\r\n            }\r\n            else {\r\n                while (board[t][colIdx].filled == true && counter < 3 && span > 3) {\r\n                    // console.log('reducing')\r\n                    //reduce l by a quarter of current span each time\r\n                    t = t + Math.floor(span/4)\r\n                    if (board[t][colIdx].filled == false && span > 3) {\r\n                        return [t, b]\r\n                    }\r\n                    span = Math.abs(t - b)\r\n                    counter += 1\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.log('column position is null with', t, b)\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n\r\n//methods for the bottom\r\n    botColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1] + 1//get offset so not looking at hall\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalL = l\r\n        //counter for a quit if the room cannot be created with the max amount of tries\r\n        var counter = 0\r\n\r\n        var span = Math.abs(l-r)\r\n        //reduce by more than a half because of offsets\r\n        l = l - Math.floor((span/4))\r\n        r = r - Math.floor(span/4)\r\n        //update the span\r\n        span = Math.abs(l - r)\r\n        var m = l + Math.floor(span/2)\r\n        try{\r\n            //if nothing has to be done return the positions as is\r\n            if(board[rowIdx][m].filled == true){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][l].filled == false && board[rowIdx][r].filled == false &&\r\n                board[rowIdx-1][l].filled == false && board[rowIdx-1][r].filled == false){//checks the bounds to make sure hall is not in the empty spaces\r\n                // console.log('returning original')\r\n                return [l,r]\r\n            }\r\n            else{\r\n                while(((board[l][rowIdx].filled == true || board[r][rowIdx].filled == true) ||\r\n                      (board[rowIdx-1][l].type !== 'H' || board[rowIdx-1][r].type !== 'H')) && \r\n                      counter < 3 && span > 3){\r\n                    // console.log('reducing')\r\n                    //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[rowIdx][l].filled == true){\r\n                        l = l + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[rowIdx][r].filled == true){\r\n                        r = r - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[rowIdx][l].filled == false && board[rowIdx][r].filled == false && originalL >= l && l < r && span > 3){\r\n                        return [l,r]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(l-r)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n    botRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var t = rowSpan[0]//l would be what would change\r\n        var b = rowSpan[1]//r would be the starting position\r\n        var counter = 0\r\n        var span = Math.abs(t-b)\r\n        var m = t + Math.floor(span/2)\r\n        try {\r\n            if(board[m][colIdx].filled == true){\r\n                return null\r\n            }\r\n            if(board[t+1][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if (board[b][colIdx].filled == false) {\r\n                return [t, b]\r\n            }\r\n            else {\r\n                while (board[b][colIdx].filled == true && counter < 3 && span > 3) {\r\n                    // console.log('reducing')\r\n                    //reduce l by a quarter of current span each time\r\n                    b = b - Math.floor(span/4)\r\n                    if (board[b][colIdx].filled == false && span > 3) {\r\n                        return [t, b]\r\n                    }\r\n                    span = Math.abs(t - b)\r\n                    counter += 1\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.log('column position is null with', t, b)\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n    //goes to generateRoom for generateRooms()\r\n    generateRoom(rowcallback, colcallback, rowSpan, colSpan, direction){\r\n        var board = this.board\r\n        //Generation of the rows and columns\r\n        const rowPosition = rowcallback(rowSpan, colSpan[0], board)\r\n        const colPosition = colcallback(colSpan, rowSpan[0], board)\r\n        if(rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n        if(rowSize < 4 || colSize < 4){\r\n            return null\r\n        }\r\n        const position = [rowPosition[0], colPosition[0]]\r\n        const room = new Room(colSize, rowSize)\r\n        const halls = this.generateHalls(1)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == direction ){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n        }\r\n\r\n        room.changePosition(position)\r\n        return room\r\n\r\n    }\r\n\r\n\r\n\r\n//where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\r\n    generateRooms(node){\r\n        const halls = node.halls\r\n        const len = halls.length\r\n        var rooms = []\r\n        let newRoom = null\r\n        let removedHalls = []\r\n        for(var i = 0; i < len; i++){\r\n            let roomSize = this.randomSize(5,7)\r\n            let rowStart = halls[i].position[0]\r\n            let colStart =  halls[i].position[1]\r\n            switch(halls[i].direction){\r\n                case 'r':\r\n                    //the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart - 1, rowStart + roomSize[0] - 1]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart , colStart + roomSize[1]]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.rightRowPositions, this.rightColPositions, rowSpan, colSpan, 'l')\r\n                        if(newRoom == null){\r\n                            removedHalls.push(halls[i])\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                case 'l':\r\n                    //the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart - 1, rowStart + roomSize[0] - 1]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart - roomSize[1] +1, colStart+1]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.leftRowPositions, this.leftColPositions, rowSpan, colSpan, 'r')\r\n                        if(newRoom == null){\r\n                            removedHalls.push(halls[i])\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                case 't':\r\n                    // the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart - roomSize[0] + 1, rowStart + 1]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart - 1, colStart + roomSize[1] - 1]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.topRowPositions, this.topColPositions, rowSpan, colSpan, 'b')\r\n                        if(newRoom == null){\r\n                            removedHalls.push(halls[i])\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                case 'b':\r\n                    //the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart, rowStart + roomSize[0]]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart - 1, colStart + roomSize[1] - 1]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.botRowPositions, this.botColPositions, rowSpan, colSpan, 't')\r\n                        if(newRoom == null){\r\n                            removedHalls.push(halls[i])\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                default:\r\n                    break\r\n            }\r\n        }\r\n        for(var i = 0; i < removedHalls.length; i++){\r\n            this.removedHalls.push(new Node('-', removedHalls[i].position))\r\n        }\r\n        return rooms\r\n    }\r\n\r\n    generateHalls(num){\r\n        var hallDirections = ['l','r','t','b']\r\n        var randomDirs = []\r\n        var counter = num\r\n        while(counter > -1){\r\n            var idx = Math.floor((Math.random() * (hallDirections.length)) + 0)\r\n            randomDirs.push(hallDirections[idx])\r\n            hallDirections.splice(idx, 1)\r\n            counter -= 1\r\n        }\r\n        return randomDirs\r\n    }\r\n\r\n    randomSize(min, max){\r\n        var length = Math.floor((Math.random() * max) + min);\r\n        var width = Math.floor((Math.random() * max) + min);\r\n        const arr = [length, width]\r\n        return arr\r\n    }\r\n    \r\n    placeRoom(room){\r\n        //where position is based on row, col for map\r\n        var rowLength = room.width\r\n        var colLength = room.height\r\n        for(var i = 0; i < rowLength; i++){\r\n            for(var j = 0; j < colLength; j++){\r\n                var row = room.contents[i][j].position[0]\r\n                var col = room.contents[i][j].position[1]\r\n                if(this.board[row][col].type !== 'H' && this.board[row][col].filled == false)\r\n                {\r\n                    this.board[row][col] = room.contents[i][j]\r\n                    this.board[row][col].filled = true\r\n                }\r\n                //this will combine the rooms into one bigger room\r\n                else if((this.board[row][col].type === 'X' || this.board[row][col].type === 'C' || this.board[row][col].type === 'H') && \r\n                room.contents[i][j].type == 'L'){\r\n                    this.board[row][col] = room.contents[i][j]\r\n                    this.board[row][col].filled = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    get contents(){\r\n        return this.board;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Map"]},"metadata":{},"sourceType":"module"}
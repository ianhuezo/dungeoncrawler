{"ast":null,"code":"import _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  //how the room itself views the node\n  function Node(roomWalls, position) {\n    _classCallCheck(this, Node);\n\n    this.type = null;\n    this.roomView = roomWalls; //position is [row, col] based\n\n    this.position = position;\n    this.nextPosition = null;\n    this.filled = false;\n\n    if (this.roomView == null) {\n      //means its a hallway/cooridor\n      this.type == 'H';\n    } else if (this.roomView.corner) {\n      //corner\n      this.type = 'C';\n    } //I don't allow corners to have rooms\n    else if (this.roomView.left || this.roomView.right || this.roomView.bottom || this.roomView.top) {\n        //\n        this.type = 'X';\n      } else {\n        this.type = 'O';\n      }\n\n    this.left = false;\n    this.right = false;\n    this.top = false;\n    this.bottom = false;\n    this.determineBarriers();\n  }\n\n  _createClass(Node, [{\n    key: \"determineBarriers\",\n    value: function determineBarriers() {\n      switch (this.type) {\n        case 'O':\n          this.fillAll();\n          break;\n\n        case 'X':\n          this.fillNone();\n\n        case 'C':\n          this.fillAll();\n\n        default:\n          this.fillNone();\n      }\n    }\n  }, {\n    key: \"fillAll\",\n    value: function fillAll() {\n      this.left = true;\n      this.right = true;\n      this.bottom = true;\n      this.top = true;\n      this.filled = true;\n    }\n  }, {\n    key: \"fillNone\",\n    value: function fillNone() {\n      this.left = false;\n      this.right = false;\n      this.bottom = false;\n      this.top = false;\n      this.filled = false;\n    }\n  }, {\n    key: \"createCooridor\",\n    value: function createCooridor(direction) {\n      //input is char for the direction \n      switch (direction) {\n        case 'l':\n          this.left = false;\n          this.right = true;\n          this.bottom = true;\n          this.top = true;\n          this.filled = false;\n\n        case 'r':\n          this.left = true;\n          this.right = false;\n          this.bottom = true;\n          this.top = true;\n          this.filled = false;\n\n        case 't':\n          this.left = true;\n          this.right = true;\n          this.bottom = true;\n          this.top = false;\n          this.filled = false;\n\n        case 'b':\n          this.left = true;\n          this.right = true;\n          this.bottom = false;\n          this.top = true;\n          this.filled = false;\n\n        default:\n          break;\n      }\n    }\n  }]);\n\n  return Node;\n}();\n\nvar Room =\n/*#__PURE__*/\nfunction () {\n  //default values for length and height\n  function Room(startingPoint) {\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : m_length;\n    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : m_width;\n\n    _classCallCheck(this, Room);\n\n    _defineProperty(this, \"length\", 10);\n\n    _defineProperty(this, \"width\", 10);\n\n    //startingPoint is the [row, col]\n    this.length = length;\n    this.width = width; //position of the whole rectangle's area\n    // this.position = {\n    //     //row col based\n    //     topLeft: [startingPoint[0], startingPoint[1]],\n    //     topRight: [startingPoint[0], startingPoint[1] + this.length - 1],\n    //     bottomLeft: [startingPoint[0] + this.width - 1, startingPoint[1]],\n    //     bottomRight: [startingPoint[0] + this.width - 1, startingPoint[1] + this.length - 1]\n    // };\n    //a list of all the nodes that can put a cooridor\n\n    this.viableSides = {\n      left: [],\n      right: [],\n      top: [],\n      bottom: [] //construct the room with all of its nodes\n\n    };\n    this.roomContents = this.constructRoom();\n  }\n\n  _createClass(Room, [{\n    key: \"constructRoom\",\n    value: function constructRoom() {\n      var roomArea = [];\n      this.constructFirstRoom(roomArea);\n      return roomArea;\n    }\n  }, {\n    key: \"constructFirstRoom\",\n    // get position(){\n    //     return this.position;\n    // }\n    value: function constructFirstRoom(area) {\n      for (var i = 0; i < this.width; i++) //row\n      {\n        var roomRow = [];\n\n        for (var j = 0; j < this.length; j++) //col\n        {\n          //get all the logic for the walls\n          var wallBooleans = this.isWall(i, j); //assign viable indices to reference later when buildling cooridors\n\n          this.buildViableCooridors(wallBooleans, [i, j]); //create roomnodes that are \n\n          var roomNode = new Node(wallBooleans, [i, j]);\n          roomRow.push(roomNode);\n        }\n\n        area.push(roomRow);\n      }\n    } //record indices that can place a cooridor in the room\n\n  }, {\n    key: \"buildViableCooridors\",\n    value: function buildViableCooridors(wall, position) {\n      if (!wall.corner) {\n        if (wall.left) {\n          this.viableSides.left.push(position);\n        } else if (wall.right) {\n          this.viableSides.right.push(position);\n        } else if (wall.top) {\n          this.viableSides.top.push(position);\n        } else if (wall.bottom) {\n          this.viableSides.bottom.push(position);\n        }\n      }\n    }\n  }, {\n    key: \"isWall\",\n    value: function isWall(row, col) {\n      //all directions walls are in\n      var isLeft = col == 0 && row < this.length;\n      var isRight = col == this.length - 1 && row < this.width;\n      var isTop = row == 0;\n      var isBottom = row == this.length - 1; //corner cases\n\n      var isTopLeft = isLeft && isTop;\n      var isTopRight = isRight && isTop;\n      var isBottomLeft = isLeft && isBottom;\n      var isBottomRight = isRight && isBottom;\n      var isCorner = isTopLeft || isTopRight || isBottomLeft || isBottomRight;\n      return {\n        right: isRight,\n        left: isLeft,\n        top: isTop,\n        bottom: isBottom,\n        topLeft: isTopLeft,\n        topRight: isTopRight,\n        bottomLeft: isBottomLeft,\n        bottomRight: isBottomRight,\n        corner: isCorner,\n        cooridor: false\n      };\n    }\n  }, {\n    key: \"buildCooridor\",\n    value: function buildCooridor(direction) {\n      //direction is the input from map that will \n      //determine where to put something\n      //builds a cooridor where the x was\n      //choose from random position\n      var randomPosition = null;\n\n      switch (direction) {\n        case 'l':\n          randomPosition = this.viableSides.left.random();\n\n        case 'r':\n          randomPosition = this.viableSides.right.random();\n\n        case 't':\n          randomPosition = this.viableSides.top.random();\n\n        case 'b':\n          randomPosition = this.viableSides.bottom.random();\n\n        default:\n          break;\n      }\n\n      var row = this.position.topLeft[0] + randomPosition[0];\n      var col = this.position.topLeft[1] + randomPosition[1]; //take the roomView attribute of the node\n\n      var cooridorNode = new Node(null, [row, col]);\n      cooridorNode.createCooridor(direction); //changes the x to become a cooridor, H\n\n      this.roomContents[col][row] = cooridorNode;\n    }\n  }, {\n    key: \"contents\",\n    get: function get() {\n      return this.roomContents;\n    }\n  }]);\n\n  return Room;\n}(); //from https://stackoverflow.com/questions/5915096/get-random-item-from-javascript-array, because looked simple and elegant\n\n\nArray.prototype.random = function () {\n  return this[Math.floor(Math.random() * this.length)];\n};\n\nexport default Room;","map":{"version":3,"sources":["D:\\Programming\\Dungeon Crawler\\pages\\room.js"],"names":["Node","roomWalls","position","type","roomView","nextPosition","filled","corner","left","right","bottom","top","determineBarriers","fillAll","fillNone","direction","Room","startingPoint","length","m_length","width","m_width","viableSides","roomContents","constructRoom","roomArea","constructFirstRoom","area","i","roomRow","j","wallBooleans","isWall","buildViableCooridors","roomNode","push","wall","row","col","isLeft","isRight","isTop","isBottom","isTopLeft","isTopRight","isBottomLeft","isBottomRight","isCorner","topLeft","topRight","bottomLeft","bottomRight","cooridor","randomPosition","random","cooridorNode","createCooridor","Array","prototype","Math","floor"],"mappings":";;;;IAAMA,I;;;AACF;AACA,gBAAYC,SAAZ,EAAuBC,QAAvB,EAAgC;AAAA;;AAC5B,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,QAAL,GAAgBH,SAAhB,CAF4B,CAG5B;;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKG,YAAL,GAAoB,IAApB;AACA,SAAKC,MAAL,GAAc,KAAd;;AAEA,QAAG,KAAKF,QAAL,IAAkB,IAArB,EAA0B;AACtB;AACA,WAAKD,IAAL,IAAa,GAAb;AACH,KAHD,MAIK,IAAG,KAAKC,QAAL,CAAcG,MAAjB,EAAwB;AACzB;AACA,WAAKJ,IAAL,GAAY,GAAZ;AACH,KAHI,CAIL;AAJK,SAKA,IAAG,KAAKC,QAAL,CAAcI,IAAd,IAAsB,KAAKJ,QAAL,CAAcK,KAApC,IAA6C,KAAKL,QAAL,CAAcM,MAA3D,IAAqE,KAAKN,QAAL,CAAcO,GAAtF,EAA0F;AAC3F;AACA,aAAKR,IAAL,GAAY,GAAZ;AACH,OAHI,MAID;AACA,aAAKA,IAAL,GAAY,GAAZ;AACH;;AACD,SAAKK,IAAL,GAAY,KAAZ;AACA,SAAKC,KAAL,GAAa,KAAb;AACA,SAAKE,GAAL,GAAW,KAAX;AACA,SAAKD,MAAL,GAAc,KAAd;AAEA,SAAKE,iBAAL;AAEH;;;;wCACkB;AACf,cAAQ,KAAKT,IAAb;AACI,aAAK,GAAL;AACI,eAAKU,OAAL;AACA;;AACJ,aAAK,GAAL;AACI,eAAKC,QAAL;;AACJ,aAAK,GAAL;AACI,eAAKD,OAAL;;AACJ;AACI,eAAKC,QAAL;AATR;AAWH;;;8BAEQ;AACL,WAAKN,IAAL,GAAY,IAAZ;AACA,WAAKC,KAAL,GAAa,IAAb;AACA,WAAKC,MAAL,GAAc,IAAd;AACA,WAAKC,GAAL,GAAW,IAAX;AACA,WAAKL,MAAL,GAAc,IAAd;AACH;;;+BAES;AACN,WAAKE,IAAL,GAAY,KAAZ;AACA,WAAKC,KAAL,GAAa,KAAb;AACA,WAAKC,MAAL,GAAc,KAAd;AACA,WAAKC,GAAL,GAAW,KAAX;AACA,WAAKL,MAAL,GAAc,KAAd;AACH;;;mCAEcS,S,EAAU;AACrB;AACA,cAAOA,SAAP;AACI,aAAK,GAAL;AACI,eAAKP,IAAL,GAAY,KAAZ;AACA,eAAKC,KAAL,GAAa,IAAb;AACA,eAAKC,MAAL,GAAc,IAAd;AACA,eAAKC,GAAL,GAAW,IAAX;AACA,eAAKL,MAAL,GAAc,KAAd;;AACJ,aAAK,GAAL;AACI,eAAKE,IAAL,GAAY,IAAZ;AACA,eAAKC,KAAL,GAAa,KAAb;AACA,eAAKC,MAAL,GAAc,IAAd;AACA,eAAKC,GAAL,GAAW,IAAX;AACA,eAAKL,MAAL,GAAc,KAAd;;AACJ,aAAK,GAAL;AACI,eAAKE,IAAL,GAAY,IAAZ;AACA,eAAKC,KAAL,GAAa,IAAb;AACA,eAAKC,MAAL,GAAc,IAAd;AACA,eAAKC,GAAL,GAAW,KAAX;AACA,eAAKL,MAAL,GAAc,KAAd;;AACJ,aAAK,GAAL;AACI,eAAKE,IAAL,GAAY,IAAZ;AACA,eAAKC,KAAL,GAAa,IAAb;AACA,eAAKC,MAAL,GAAc,KAAd;AACA,eAAKC,GAAL,GAAW,IAAX;AACA,eAAKL,MAAL,GAAc,KAAd;;AACJ;AACI;AA1BR;AA4BH;;;;;;IAKCU,I;;;AACF;AAGA,gBAAYC,aAAZ,EAA8D;AAAA,QAAnCC,MAAmC,uEAA1BC,QAA0B;AAAA,QAAhBC,KAAgB,uEAARC,OAAQ;;AAAA;;AAAA,oCAFrD,EAEqD;;AAAA,mCADtD,EACsD;;AAC1D;AACA,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKE,KAAL,GAAaA,KAAb,CAH0D,CAI1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAKE,WAAL,GAAmB;AACfd,MAAAA,IAAI,EAAG,EADQ;AAEfC,MAAAA,KAAK,EAAE,EAFQ;AAGfE,MAAAA,GAAG,EAAE,EAHU;AAIfD,MAAAA,MAAM,EAAE,EAJO,CAMnB;;AANmB,KAAnB;AAOA,SAAKa,YAAL,GAAoB,KAAKC,aAAL,EAApB;AACH;;;;oCACc;AAEX,UAAIC,QAAQ,GAAG,EAAf;AACA,WAAKC,kBAAL,CAAwBD,QAAxB;AACA,aAAOA,QAAP;AACH;;;AAMD;AACA;AACA;uCAEmBE,I,EAAK;AACpB,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKR,KAAzB,EAAgCQ,CAAC,EAAjC,EAAoC;AACpC;AACI,YAAIC,OAAO,GAAG,EAAd;;AACA,aAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,KAAKZ,MAAxB,EAAgCY,CAAC,EAAjC,EAAoC;AACpC;AACI;AACA,cAAIC,YAAY,GAAG,KAAKC,MAAL,CAAYJ,CAAZ,EAAeE,CAAf,CAAnB,CAFJ,CAGI;;AACA,eAAKG,oBAAL,CAA0BF,YAA1B,EAAwC,CAACH,CAAD,EAAGE,CAAH,CAAxC,EAJJ,CAKI;;AACA,cAAII,QAAQ,GAAG,IAAIlC,IAAJ,CAAS+B,YAAT,EAAuB,CAACH,CAAD,EAAGE,CAAH,CAAvB,CAAf;AACAD,UAAAA,OAAO,CAACM,IAAR,CAAaD,QAAb;AACH;;AACDP,QAAAA,IAAI,CAACQ,IAAL,CAAUN,OAAV;AACH;AACJ,K,CACD;;;;yCACqBO,I,EAAMlC,Q,EAAS;AAChC,UAAG,CAACkC,IAAI,CAAC7B,MAAT,EAAgB;AACZ,YAAG6B,IAAI,CAAC5B,IAAR,EAAa;AACT,eAAKc,WAAL,CAAiBd,IAAjB,CAAsB2B,IAAtB,CAA2BjC,QAA3B;AACH,SAFD,MAGK,IAAGkC,IAAI,CAAC3B,KAAR,EAAc;AACf,eAAKa,WAAL,CAAiBb,KAAjB,CAAuB0B,IAAvB,CAA4BjC,QAA5B;AACH,SAFI,MAGA,IAAGkC,IAAI,CAACzB,GAAR,EAAY;AACb,eAAKW,WAAL,CAAiBX,GAAjB,CAAqBwB,IAArB,CAA0BjC,QAA1B;AACH,SAFI,MAGA,IAAGkC,IAAI,CAAC1B,MAAR,EAAe;AAChB,eAAKY,WAAL,CAAiBZ,MAAjB,CAAwByB,IAAxB,CAA6BjC,QAA7B;AACH;AAEJ;AACJ;;;2BAEMmC,G,EAAKC,G,EAAI;AACZ;AACA,UAAMC,MAAM,GAAID,GAAG,IAAI,CAAP,IAAYD,GAAG,GAAG,KAAKnB,MAAvC;AACA,UAAMsB,OAAO,GAAIF,GAAG,IAAI,KAAKpB,MAAL,GAAY,CAAnB,IAAwBmB,GAAG,GAAG,KAAKjB,KAApD;AACA,UAAMqB,KAAK,GAAIJ,GAAG,IAAI,CAAtB;AACA,UAAMK,QAAQ,GAAIL,GAAG,IAAI,KAAKnB,MAAL,GAAc,CAAvC,CALY,CAMZ;;AACA,UAAMyB,SAAS,GAAGJ,MAAM,IAAIE,KAA5B;AACA,UAAMG,UAAU,GAAGJ,OAAO,IAAIC,KAA9B;AACA,UAAMI,YAAY,GAAGN,MAAM,IAAIG,QAA/B;AACA,UAAMI,aAAa,GAAGN,OAAO,IAAIE,QAAjC;AACA,UAAMK,QAAQ,GAAIJ,SAAS,IAAIC,UAAb,IAA2BC,YAA3B,IAA2CC,aAA7D;AACA,aAAO;AACHrC,QAAAA,KAAK,EAAE+B,OADJ;AAEHhC,QAAAA,IAAI,EAAE+B,MAFH;AAGH5B,QAAAA,GAAG,EAAE8B,KAHF;AAIH/B,QAAAA,MAAM,EAAEgC,QAJL;AAKHM,QAAAA,OAAO,EAAEL,SALN;AAMHM,QAAAA,QAAQ,EAAEL,UANP;AAOHM,QAAAA,UAAU,EAAEL,YAPT;AAQHM,QAAAA,WAAW,EAAEL,aARV;AASHvC,QAAAA,MAAM,EAAEwC,QATL;AAUHK,QAAAA,QAAQ,EAAE;AAVP,OAAP;AAYH;;;kCAEarC,S,EAAU;AACpB;AACA;AACA;AACA;AACA,UAAIsC,cAAc,GAAG,IAArB;;AACA,cAAOtC,SAAP;AACI,aAAK,GAAL;AACIsC,UAAAA,cAAc,GAAG,KAAK/B,WAAL,CAAiBd,IAAjB,CAAsB8C,MAAtB,EAAjB;;AACJ,aAAK,GAAL;AACID,UAAAA,cAAc,GAAG,KAAK/B,WAAL,CAAiBb,KAAjB,CAAuB6C,MAAvB,EAAjB;;AACJ,aAAK,GAAL;AACID,UAAAA,cAAc,GAAG,KAAK/B,WAAL,CAAiBX,GAAjB,CAAqB2C,MAArB,EAAjB;;AACJ,aAAK,GAAL;AACID,UAAAA,cAAc,GAAG,KAAK/B,WAAL,CAAiBZ,MAAjB,CAAwB4C,MAAxB,EAAjB;;AACJ;AACI;AAVR;;AAYA,UAAIjB,GAAG,GAAG,KAAKnC,QAAL,CAAc8C,OAAd,CAAsB,CAAtB,IAA2BK,cAAc,CAAC,CAAD,CAAnD;AACA,UAAIf,GAAG,GAAG,KAAKpC,QAAL,CAAc8C,OAAd,CAAsB,CAAtB,IAA2BK,cAAc,CAAC,CAAD,CAAnD,CAnBoB,CAoBpB;;AACA,UAAIE,YAAY,GAAG,IAAIvD,IAAJ,CAAS,IAAT,EAAe,CAACqC,GAAD,EAAKC,GAAL,CAAf,CAAnB;AACAiB,MAAAA,YAAY,CAACC,cAAb,CAA4BzC,SAA5B,EAtBoB,CAuBpB;;AACA,WAAKQ,YAAL,CAAkBe,GAAlB,EAAuBD,GAAvB,IAA8BkB,YAA9B;AACH;;;wBA/Fa;AACV,aAAO,KAAKhC,YAAZ;AACH;;;;KAgGL;;;AACAkC,KAAK,CAACC,SAAN,CAAgBJ,MAAhB,GAAyB,YAAY;AACjC,SAAO,KAAKK,IAAI,CAACC,KAAL,CAAYD,IAAI,CAACL,MAAL,KAAc,KAAKpC,MAA/B,CAAL,CAAP;AACD,CAFH;;AAIA,eAAeF,IAAf","sourcesContent":["class Node{\r\n    //how the room itself views the node\r\n    constructor(roomWalls, position){\r\n        this.type = null;\r\n        this.roomView = roomWalls\r\n        //position is [row, col] based\r\n        this.position = position\r\n        this.nextPosition = null\r\n        this.filled = false\r\n\r\n        if(this.roomView ==  null){\r\n            //means its a hallway/cooridor\r\n            this.type == 'H'\r\n        }\r\n        else if(this.roomView.corner){\r\n            //corner\r\n            this.type = 'C';\r\n        }\r\n        //I don't allow corners to have rooms\r\n        else if(this.roomView.left || this.roomView.right || this.roomView.bottom || this.roomView.top){\r\n            //\r\n            this.type = 'X';\r\n        }\r\n        else{\r\n            this.type = 'O';\r\n        }\r\n        this.left = false;\r\n        this.right = false;\r\n        this.top = false;\r\n        this.bottom = false;\r\n\r\n        this.determineBarriers();\r\n\r\n    }\r\n    determineBarriers(){\r\n        switch (this.type){\r\n            case 'O':\r\n                this.fillAll()\r\n                break\r\n            case 'X':\r\n                this.fillNone()\r\n            case 'C':\r\n                this.fillAll()\r\n            default:\r\n                this.fillNone()\r\n        }\r\n    }\r\n\r\n    fillAll(){\r\n        this.left = true\r\n        this.right = true\r\n        this.bottom = true\r\n        this.top = true\r\n        this.filled = true\r\n    }\r\n\r\n    fillNone(){\r\n        this.left = false\r\n        this.right = false\r\n        this.bottom = false\r\n        this.top = false\r\n        this.filled = false\r\n    }\r\n\r\n    createCooridor(direction){\r\n        //input is char for the direction \r\n        switch(direction){\r\n            case 'l':\r\n                this.left = false\r\n                this.right = true\r\n                this.bottom = true\r\n                this.top = true\r\n                this.filled = false\r\n            case 'r':\r\n                this.left = true\r\n                this.right = false\r\n                this.bottom = true\r\n                this.top = true\r\n                this.filled = false\r\n            case 't':\r\n                this.left = true\r\n                this.right = true\r\n                this.bottom = true\r\n                this.top = false\r\n                this.filled = false\r\n            case 'b':\r\n                this.left = true\r\n                this.right = true\r\n                this.bottom = false\r\n                this.top = true\r\n                this.filled = false\r\n            default:\r\n                break\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nclass Room{\r\n    //default values for length and height\r\n    length = 10;\r\n    width = 10;\r\n    constructor(startingPoint, length = m_length, width = m_width){\r\n        //startingPoint is the [row, col]\r\n        this.length = length;\r\n        this.width = width;\r\n        //position of the whole rectangle's area\r\n        // this.position = {\r\n        //     //row col based\r\n        //     topLeft: [startingPoint[0], startingPoint[1]],\r\n        //     topRight: [startingPoint[0], startingPoint[1] + this.length - 1],\r\n        //     bottomLeft: [startingPoint[0] + this.width - 1, startingPoint[1]],\r\n        //     bottomRight: [startingPoint[0] + this.width - 1, startingPoint[1] + this.length - 1]\r\n        // };\r\n        //a list of all the nodes that can put a cooridor\r\n        this.viableSides = {\r\n            left : [],\r\n            right: [],\r\n            top: [],\r\n            bottom: []\r\n        }\r\n        //construct the room with all of its nodes\r\n        this.roomContents = this.constructRoom();\r\n    }\r\n    constructRoom(){\r\n       \r\n        let roomArea = [];\r\n        this.constructFirstRoom(roomArea)\r\n        return roomArea;\r\n    }\r\n\r\n    get contents(){\r\n        return this.roomContents;\r\n    }\r\n\r\n    // get position(){\r\n    //     return this.position;\r\n    // }\r\n\r\n    constructFirstRoom(area){\r\n        for (var i = 0; i < this.width; i++)//row\r\n        {\r\n            let roomRow = [];\r\n            for(var j = 0; j < this.length; j++)//col\r\n            {\r\n                //get all the logic for the walls\r\n                let wallBooleans = this.isWall(i, j);\r\n                //assign viable indices to reference later when buildling cooridors\r\n                this.buildViableCooridors(wallBooleans, [i,j])\r\n                //create roomnodes that are \r\n                let roomNode = new Node(wallBooleans, [i,j])\r\n                roomRow.push(roomNode);\r\n            }\r\n            area.push(roomRow);\r\n        }\r\n    }\r\n    //record indices that can place a cooridor in the room\r\n    buildViableCooridors(wall, position){\r\n        if(!wall.corner){\r\n            if(wall.left){\r\n                this.viableSides.left.push(position)\r\n            }\r\n            else if(wall.right){\r\n                this.viableSides.right.push(position)\r\n            }\r\n            else if(wall.top){\r\n                this.viableSides.top.push(position)\r\n            }\r\n            else if(wall.bottom){\r\n                this.viableSides.bottom.push(position)\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    isWall(row, col){\r\n        //all directions walls are in\r\n        const isLeft = (col == 0 && row < this.length);\r\n        const isRight = (col == this.length-1 && row < this.width);\r\n        const isTop = (row == 0);\r\n        const isBottom = (row == this.length - 1);\r\n        //corner cases\r\n        const isTopLeft = isLeft && isTop;\r\n        const isTopRight = isRight && isTop;\r\n        const isBottomLeft = isLeft && isBottom;\r\n        const isBottomRight = isRight && isBottom;\r\n        const isCorner = (isTopLeft || isTopRight || isBottomLeft || isBottomRight);\r\n        return {\r\n            right: isRight,\r\n            left: isLeft,\r\n            top: isTop,\r\n            bottom: isBottom,\r\n            topLeft: isTopLeft,\r\n            topRight: isTopRight,\r\n            bottomLeft: isBottomLeft,\r\n            bottomRight: isBottomRight,\r\n            corner: isCorner,\r\n            cooridor: false\r\n        }\r\n    }\r\n\r\n    buildCooridor(direction){\r\n        //direction is the input from map that will \r\n        //determine where to put something\r\n        //builds a cooridor where the x was\r\n        //choose from random position\r\n        var randomPosition = null\r\n        switch(direction){\r\n            case 'l':\r\n                randomPosition = this.viableSides.left.random()\r\n            case 'r':\r\n                randomPosition = this.viableSides.right.random()\r\n            case 't':\r\n                randomPosition = this.viableSides.top.random()\r\n            case 'b':\r\n                randomPosition = this.viableSides.bottom.random()\r\n            default:\r\n                break\r\n        }\r\n        var row = this.position.topLeft[0] + randomPosition[0]\r\n        var col = this.position.topLeft[1] + randomPosition[1]\r\n        //take the roomView attribute of the node\r\n        var cooridorNode = new Node(null, [row,col])\r\n        cooridorNode.createCooridor(direction)\r\n        //changes the x to become a cooridor, H\r\n        this.roomContents[col][row] = cooridorNode\r\n    }\r\n\r\n}\r\n//from https://stackoverflow.com/questions/5915096/get-random-item-from-javascript-array, because looked simple and elegant\r\nArray.prototype.random = function () {\r\n    return this[Math.floor((Math.random()*this.length))];\r\n  }\r\n\r\nexport default Room"]},"metadata":{},"sourceType":"module"}
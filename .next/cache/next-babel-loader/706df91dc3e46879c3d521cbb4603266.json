{"ast":null,"code":"import _readOnlyError from \"@babel/runtime-corejs2/helpers/esm/readOnlyError\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { Room, Node } from './room';\n\nvar Map =\n/*#__PURE__*/\nfunction () {\n  function Map(boardWidth, boardlength) {\n    _classCallCheck(this, Map);\n\n    //describes the boards with relative to amount of squares\n    this.width = boardWidth;\n    this.height = boardlength;\n    this.clearedBoard = []; //initialize the board with a clear state\n\n    this.clear();\n    this.board = this.clearedBoard;\n    this.roomCounter = 8;\n    this.createRooms(this.roomCounter);\n  }\n\n  _createClass(Map, [{\n    key: \"clear\",\n    value: function clear() {\n      for (var i = 0; i < this.height; i++) {\n        var arr = [];\n\n        for (var j = 0; j < this.width; j++) {\n          var emptyNodes = new Node('-', [i, j]);\n          arr.push(emptyNodes);\n        }\n\n        this.clearedBoard.push(arr);\n      }\n    }\n  }, {\n    key: \"createRooms\",\n    value: function createRooms(roomNumber) {\n      var roomCount = roomNumber;\n      var randomSize = this.randomSize(5, 7);\n      var roomNode = new Room(randomSize[0], randomSize[1]); // //create some halls\n\n      var halls = this.generateHalls(2); //initialize queue\n\n      var position = [25, 40];\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        roomNode.buildCooridor(halls[i]);\n      }\n\n      roomNode.changePosition(position);\n      roomNode.visited = true;\n      this.placeRoom(roomNode);\n      var queue = [];\n      queue.push(roomNode);\n      var randomCount = 5;\n\n      while (queue.length) {\n        var node = queue.shift(0);\n\n        if (node) {\n          var rooms = this.generateRooms(node);\n\n          for (var i = 0; i < rooms.length; i++) {\n            this.placeRoom(rooms[i]);\n            queue.push(rooms[i]);\n          }\n\n          randomCount -= 1;\n        }\n\n        randomCount -= 1;\n      }\n    } //methods for the right\n\n  }, {\n    key: \"searchRightColPosition\",\n    value: function searchRightColPosition(rowIdx, colSpan) {\n      var l = colSpan[0];\n      var r = colSpan[1];\n      var span = r - l;\n      var counter = 0; //if the index is not filled then you're fine, return r\n\n      if (this.board[rowIdx][r].filled == false) {\n        return [l, r];\n      } //else if its a bad index binary search for a good one unless there isn't one\n      else {\n          while (this.board[rowIdx][r].filled == true && counter < 3) {\n            var half = Math.floor(span / 2 + l);\n            console.log('Right col is readjusting...');\n\n            if (this.board[rowIdx][half].filled == false) {\n              return [l, half];\n            } else {\n              span = half - 1;\n            }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    } //shared method for both left and right\n\n  }, {\n    key: \"searchTopBottomRowPosition\",\n    value: function searchTopBottomRowPosition(rowSpan, colIdx) {\n      //returns an array of the top and bottom indices for the rows\n      var t = rowSpan[0] + 1;\n      var b = rowSpan[1] + 1; //the span of the rows\n\n      var span = Math.abs(t - b); //offset by half\n\n      t = t - Math.floor(span / 3);\n\n      if (t < 0) {\n        t = 0;\n      }\n\n      b = b - Math.floor(span / 3);\n      var counter = 0; //search both top and bottom for a good offset\n\n      if (this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false) {\n        return [t, b];\n      } //quarters\n      else {\n          while (this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false && counter < 3) {\n            console.log('Top Bottom is readjusting...');\n            var topQuartile = Math.ceil(span / 4 + t); //because bottom is lower in count...\n\n            var bottomQuartile = Math.ceil(b - span / 4);\n\n            if (this.board[topQuartile][colIdx].filled == true && this.board[bottomQuartile][colIdx].filled == true) {\n              return [topQuartile, bottomQuartile];\n            } //could be more complex statements  depending on the dungeon I decide\n            else {\n                t = Math.ceil(span / 4 + t) + 1;\n                b = Math.ceil(b - span / 4) - 1;\n              }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    }\n  }, {\n    key: \"placeRight\",\n    value: function placeRight(pos, dir) {\n      //need to account for the offset from the non filled room\n      pos = [pos[0] - 1, pos[1]];\n      var roomSize = this.randomSize(5, 7);\n      var rowSpan = [pos[0], pos[0] + roomSize[0]];\n      var colSpan = [pos[1], pos[1] + roomSize[1]]; //the positions returned are the span of the element indices\n\n      var colPosition = this.searchRightColPosition(pos[0], colSpan); //add 1 to cols to avoid looking at the hall's positions\n\n      var rowPosition = this.searchTopBottomRowPosition(rowSpan, pos[1] + 1);\n\n      if (rowSize < 4 || colSize < 4 || rowPosition == null || colPosition == null) {\n        return null;\n      } //position from the top left\n\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]);\n      var room = new Room(rowSize, colSize); //position the room\n\n      var newPosition = [rowPosition[0], colPosition[0]];\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == dir || this.roomCounter == 0) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n        this.roomCounter -= 1;\n      }\n\n      room.changePosition(newPosition);\n      return room;\n    } //Methods for the left\n\n  }, {\n    key: \"searchLeftColPosition\",\n    value: function searchLeftColPosition(rowIdx, colSpan) {\n      var l = Math.abs(Math.floor(colSpan[0]));\n      var r = Math.abs(Math.floor(colSpan[1]));\n      var span = Math.abs(r - l);\n      var counter = 0; //if the index at l is not filled then you're fine, return\n\n      try {\n        if (this.board[rowIdx][l].filled == false) {\n          return [l, r];\n        } //else if its a bad index binary search for a good one unless there isn't one\n        else {\n            while (this.board[rowIdx][r].filled == true && counter < 3) {\n              var half = Math.floor(span / 4 + l);\n              console.log('Left col is readjusting...');\n\n              if (this.board[rowIdx][half].filled == false) {\n                return [l, half];\n              } else {\n                span = (_readOnlyError(\"span\"), half - 1);\n              }\n\n              counter += 1;\n            }\n          }\n\n        return null;\n      } catch (e) {\n        console.log(rowIdx, l, r);\n      }\n    }\n  }, {\n    key: \"placeLeft\",\n    value: function placeLeft(pos, dir) {\n      //create the offsets for position and create the roomsize\n      var offset = [pos[0] - 1, pos[1]];\n      var roomSize = this.randomSize(5, 7);\n      var rowSpan = [offset[0], offset[0] + roomSize[1]];\n      var colSpan = [offset[1] - roomSize[1] + 1, offset[1]]; //the positions returned are the span of the element indices\n\n      var colPosition = this.searchLeftColPosition(rowSpan[0], colSpan);\n      var rowPosition = this.searchTopBottomRowPosition(rowSpan, pos[1] + 1);\n\n      if (rowSize < 4 || colSize < 4 || rowPosition == null || colPosition == null) {\n        return null;\n      }\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]); //create and place the final room\n\n      var room = new Room(rowSize, colSize);\n      var position = [rowPosition[0], colPosition[0]];\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == dir || this.roomCounter == 0) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n        this.roomCounter -= 1;\n      }\n\n      room.changePosition(position);\n      return room;\n    } //top logic \n\n  }, {\n    key: \"placeTop\",\n    value: function placeTop(pos, dir) {\n      //create the offsets for position and create the roomsize\n      var offset = [pos[0] + 1, pos[1]];\n      var roomSize = this.randomSize(5, 7);\n      var rowSpan = [offset[0] - roomSize[1], offset[0]];\n      var colSpan = [offset[1], offset[1] + roomSize[1]]; //the positions returned are the span of the element indices\n\n      var rowPosition = this.searchTopRowPosition(colSpan[0], rowSpan);\n      var colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0]);\n\n      if (rowSize < 4 || colSize < 4 || rowPosition == null || colPosition == null) {\n        return null;\n      }\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]);\n      var room = new Room(rowSize, colSize);\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == dir || this.roomCounter == 0) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n        this.roomCounter -= 1;\n      }\n\n      room.changePosition([rowPosition[0], colPosition[0]]);\n      return room;\n    }\n  }, {\n    key: \"searchLeftRightPosition\",\n    value: function searchLeftRightPosition(colSpan, rowIdx) {\n      var t = Math.abs(colSpan[0]);\n      var b = Math.abs(colSpan[1]); //the span of the rows\n\n      var span = Math.abs(t - b); //offset by half\n\n      t = t - Math.floor(span / 3);\n      b = b - Math.floor(span / 3);\n      t = Math.abs(t);\n      b = Math.abs(b);\n      rowIdx = Math.abs(rowIdx);\n      var counter = 0; //search both top and bottom for a good offset\n\n      if (this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false) {\n        return [t, b];\n      } //quarters\n      else {\n          while (this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false && counter < 3) {\n            var topQuartile = Math.ceil(span / 4 + t); //because bottom is lower in count...\n\n            var bottomQuartile = Math.ceil(b - span / 4);\n\n            if (this.board[rowIdx][topQuartile].filled == true && this.board[rowIdx][bottomQuartile].filled == true) {\n              return [topQuartile, bottomQuartile];\n            } //could be more complex statements  depending on the dungeon I decide\n            else {\n                t = Math.ceil(span / 4 + t) + 1;\n                b = Math.ceil(b - span / 4) - 1;\n              }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    }\n  }, {\n    key: \"searchTopRowPosition\",\n    value: function searchTopRowPosition(colIndex, rowSpan) {\n      var l = Math.abs(Math.floor(rowSpan[0]));\n      var r = Math.abs(Math.floor(rowSpan[1]));\n      var span = Math.abs(l - r);\n      var counter = 0; //if the index at l is not filled then you're fine, return \n\n      if (this.board[l][colIndex].filled == false) {\n        return [l, r];\n      } //else if its a bad index binary search for a good one unless there isn'l one\n      else {\n          while (this.board[l][colIndex].filled == true && counter < 3) {\n            console.log('Top row is readjusting...');\n            var half = Math.floor(l + span / 4);\n\n            if (this.board[half][colIndex].filled == false) {\n              return [half, r];\n            } else {\n              span = half + 1;\n            }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    }\n  }, {\n    key: \"searchBottomRowPosition\",\n    value: function searchBottomRowPosition(colIndex, rowSpan) {\n      var l = rowSpan[0];\n      var r = rowSpan[1];\n      var span = Math.abs(l - r);\n      var counter = 0; //if the index at l is not filled then you're fine, return \n\n      if (this.board[r][colIndex].filled == false) {\n        return [l, r];\n      } //else if its a bad index binary search for a good one unless there isn'l one\n      else {\n          while (this.board[l][colIndex].filled == true && counter < 3) {\n            var half = Math.floor(r - span / 4);\n            console.log('Bottom row is readjusting...');\n\n            if (this.board[half][colIndex].filled == false) {\n              return [half, r];\n            } else {\n              span = half - 1;\n            }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    } //bottom room logic\n\n  }, {\n    key: \"placeBottom\",\n    value: function placeBottom(pos, dir) {\n      //create the offsets for position and create the roomsize\n      var offset = [pos[0], pos[1]];\n      var roomSize = this.randomSize(5, 7);\n      var rowSpan = [offset[0], offset[0] + roomSize[0]];\n      var colSpan = [offset[1], offset[1] + roomSize[1]]; //the positions returned are the span of the element indices\n\n      var rowPosition = this.searchTopRowPosition(colSpan[0], rowSpan);\n      var colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0]);\n\n      if (rowSize < 4 || colSize < 4 || rowPosition == null || colPosition == null) {\n        return null;\n      }\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]);\n      var room = new Room(rowSize, colSize);\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == dir || this.roomCounter == 0) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n        this.roomCounter -= 1;\n      }\n\n      room.changePosition([rowPosition[0], colPosition[0]]);\n      return room;\n    } //where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\n\n  }, {\n    key: \"generateRooms\",\n    value: function generateRooms(node) {\n      var halls = node.halls;\n      var len = halls.length;\n      var rooms = [];\n      var newRoom = null;\n\n      for (var i = 0; i < len; i++) {\n        switch (halls[i].direction) {\n          case 'r':\n            newRoom = this.placeRight(halls[i].position, 'l');\n\n            if (newRoom) {\n              newRoom.parentHall = halls[i];\n              rooms.push(newRoom);\n            } else {\n              //remove the cooridor because it's not viable\n              this.roomCounter += 1;\n              node.removeCooridor(halls[i].direction);\n            }\n\n            break;\n\n          case 'l':\n            newRoom = this.placeLeft(halls[i].position, 'r');\n\n            if (newRoom) {\n              newRoom.parentHall = halls[i];\n              rooms.push(newRoom);\n            } else {\n              //remove the cooridor because it's not viable\n              this.roomCounter += 1;\n              node.removeCooridor(halls[i].direction);\n            }\n\n            break;\n\n          case 't':\n            newRoom = this.placeTop(halls[i].position, 'b');\n\n            if (newRoom) {\n              newRoom.parentHall = halls[i];\n              rooms.push(newRoom);\n            } else {\n              //remove the cooridor because it's not viable\n              this.roomCounter += 1;\n              node.removeCooridor(halls[i].direction);\n            }\n\n            break;\n\n          case 'b':\n            newRoom = this.placeBottom(halls[i].position, 't');\n\n            if (newRoom) {\n              newRoom.parentHall = halls[i];\n              rooms.push(newRoom);\n            } else {\n              //remove the cooridor because it's not viable\n              this.roomCounter += 1;\n              node.removeCooridor(halls[i].direction);\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return rooms;\n    }\n  }, {\n    key: \"generateHalls\",\n    value: function generateHalls(num) {\n      var hallDirections = ['l', 'r', 't', 'b'];\n      var randomDirs = [];\n      var counter = num;\n\n      while (counter > -1) {\n        var idx = Math.floor(Math.random() * hallDirections.length + 0);\n        randomDirs.push(hallDirections[idx]);\n        hallDirections.splice(idx, 1);\n        counter -= 1;\n      }\n\n      return randomDirs;\n    }\n  }, {\n    key: \"randomSize\",\n    value: function randomSize(min, max) {\n      var length = Math.floor(Math.random() * max + min);\n      var width = Math.floor(Math.random() * max + min);\n      var arr = [length, width];\n      return arr;\n    }\n  }, {\n    key: \"placeRoom\",\n    value: function placeRoom(room) {\n      //where position is based on row, col for map\n      var rowLength = room.width;\n      var colLength = room.height;\n\n      for (var i = 0; i < rowLength; i++) {\n        for (var j = 0; j < colLength; j++) {\n          var row = room.contents[i][j].position[0];\n          var col = room.contents[i][j].position[1];\n\n          if (this.board[row][col].type !== 'H') {\n            this.board[row][col] = room.contents[i][j];\n            this.board[row][col].filled = true;\n          } else {\n            this.board[row][col].filled = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"contents\",\n    get: function get() {\n      return this.board;\n    }\n  }]);\n\n  return Map;\n}();\n\nexport default Map;","map":{"version":3,"sources":["D:\\Programming\\Dungeon Crawler\\pages\\map.js"],"names":["Room","Node","Map","boardWidth","boardlength","width","height","clearedBoard","clear","board","roomCounter","createRooms","i","arr","j","emptyNodes","push","roomNumber","roomCount","randomSize","roomNode","halls","generateHalls","position","length","buildCooridor","changePosition","visited","placeRoom","queue","randomCount","node","shift","rooms","generateRooms","rowIdx","colSpan","l","r","span","counter","filled","half","Math","floor","console","log","rowSpan","colIdx","t","b","abs","topQuartile","ceil","bottomQuartile","pos","dir","roomSize","colPosition","searchRightColPosition","rowPosition","searchTopBottomRowPosition","rowSize","colSize","room","newPosition","e","offset","searchLeftColPosition","searchTopRowPosition","searchLeftRightPosition","colIndex","len","newRoom","direction","placeRight","parentHall","removeCooridor","placeLeft","placeTop","placeBottom","num","hallDirections","randomDirs","idx","random","splice","min","max","rowLength","colLength","row","contents","col","type"],"mappings":"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","sourcesContent":["import {Room, Node} from './room'\r\n\r\nclass Map{\r\n    constructor(boardWidth, boardlength){\r\n        //describes the boards with relative to amount of squares\r\n        this.width = boardWidth;\r\n        this.height = boardlength;\r\n        this.clearedBoard = [];\r\n        //initialize the board with a clear state\r\n        this.clear()\r\n        this.board = this.clearedBoard\r\n        this.roomCounter = 8\r\n        this.createRooms(this.roomCounter)\r\n    }\r\n\r\n    clear(){\r\n        for(var i = 0; i < this.height; i++){\r\n            let arr = []\r\n            for(var j = 0; j < this.width; j++){\r\n                var emptyNodes = new Node('-', [i,j])\r\n                arr.push(emptyNodes)\r\n            }\r\n            this.clearedBoard.push(arr)\r\n        }\r\n    }\r\n    \r\n    createRooms(roomNumber){\r\n\r\n        var roomCount = roomNumber\r\n        var randomSize = this.randomSize(5, 7)\r\n        var roomNode = new Room(randomSize[0], randomSize[1])\r\n        // //create some halls\r\n        var halls = this.generateHalls(2)\r\n        //initialize queue\r\n        var position = [25,40]\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            roomNode.buildCooridor(halls[i])\r\n        }\r\n        roomNode.changePosition(position)\r\n        roomNode.visited = true\r\n\r\n        this.placeRoom(roomNode)\r\n\r\n        var queue = []\r\n        queue.push(roomNode)\r\n        var randomCount = 5\r\n        while(queue.length){\r\n            var node = queue.shift(0)\r\n            if(node)\r\n            {\r\n                var rooms = this.generateRooms(node)\r\n                for(var i = 0; i < rooms.length; i++){\r\n                    this.placeRoom(rooms[i])\r\n                    queue.push(rooms[i])\r\n                }\r\n                randomCount -= 1\r\n            }\r\n            randomCount -= 1\r\n        }\r\n\r\n\r\n    }\r\n//methods for the right\r\n    searchRightColPosition(rowIdx, colSpan){\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n        var span = r - l\r\n        var counter = 0\r\n        //if the index is not filled then you're fine, return r\r\n        if(this.board[rowIdx][r].filled == false){\r\n            return [l,r]\r\n        }\r\n        //else if its a bad index binary search for a good one unless there isn't one\r\n        else{\r\n            while(this.board[rowIdx][r].filled == true && counter < 3){\r\n                var half = Math.floor((span/2) + l)\r\n                console.log('Right col is readjusting...')\r\n                if(this.board[rowIdx][half].filled == false){\r\n                    return [l,half]\r\n                }\r\n                else{\r\n                    span = half - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n    //shared method for both left and right\r\n    searchTopBottomRowPosition(rowSpan, colIdx){\r\n        //returns an array of the top and bottom indices for the rows\r\n        var t = rowSpan[0] + 1\r\n        var b = rowSpan[1] + 1\r\n        //the span of the rows\r\n        var span = Math.abs(t-b)\r\n        //offset by half\r\n        t = t - Math.floor(span/3)\r\n        if(t < 0){\r\n            t = 0\r\n        }\r\n        b = b - Math.floor(span/3)\r\n        var counter = 0\r\n\r\n        //search both top and bottom for a good offset\r\n        if(this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false){\r\n            return [t,b]\r\n        }\r\n        //quarters\r\n        else{\r\n            while(this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false && counter < 3){\r\n                console.log('Top Bottom is readjusting...')\r\n                var topQuartile = Math.ceil((span/4) + t)\r\n                //because bottom is lower in count...\r\n                var bottomQuartile = Math.ceil(b - (span/4))\r\n                if(this.board[topQuartile][colIdx].filled == true && this.board[bottomQuartile][colIdx].filled == true){\r\n                    return [topQuartile, bottomQuartile]\r\n                }\r\n                //could be more complex statements  depending on the dungeon I decide\r\n                else{\r\n                    t = Math.ceil((span/4) + t) + 1\r\n                    b = Math.ceil(b - (span/4)) - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    placeRight(pos,dir){\r\n        //need to account for the offset from the non filled room\r\n        pos = [pos[0] - 1, pos[1]]\r\n        var roomSize = this.randomSize(5,7)\r\n        var rowSpan = [pos[0], pos[0] + roomSize[0]]\r\n        var colSpan = [pos[1], pos[1] + roomSize[1]]\r\n        //the positions returned are the span of the element indices\r\n        var colPosition = this.searchRightColPosition(pos[0],colSpan)\r\n        //add 1 to cols to avoid looking at the hall's positions\r\n        var rowPosition = this.searchTopBottomRowPosition(rowSpan,pos[1] + 1)\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        //position from the top left\r\n        var rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        var colSize = Math.abs(colPosition[1] - colPosition[0])\r\n        var room = new Room(rowSize, colSize)\r\n        //position the room\r\n        var newPosition = [rowPosition[0], colPosition[0]]\r\n        const halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition(newPosition)\r\n        return room\r\n    }\r\n\r\n    //Methods for the left\r\n    searchLeftColPosition(rowIdx,colSpan){\r\n        const l = Math.abs(Math.floor(colSpan[0]))\r\n        const r = Math.abs(Math.floor(colSpan[1]))\r\n        const span = Math.abs(r - l)\r\n        var counter = 0\r\n        //if the index at l is not filled then you're fine, return\r\n        try{\r\n            if(this.board[rowIdx][l].filled == false){\r\n                return [l,r]\r\n            }\r\n            //else if its a bad index binary search for a good one unless there isn't one\r\n            else{\r\n                while(this.board[rowIdx][r].filled == true && counter < 3){\r\n                    var half = Math.floor((span/4) + l)\r\n                    console.log('Left col is readjusting...')\r\n                    if(this.board[rowIdx][half].filled == false){\r\n                        return [l,half]\r\n                    }\r\n                    else{\r\n                        span = half - 1\r\n                    }\r\n                    counter += 1\r\n                }\r\n            }\r\n            return null\r\n        }\r\n        catch(e){\r\n            console.log(rowIdx, l, r)\r\n        }\r\n\r\n    }\r\n    \r\n    placeLeft(pos,dir){\r\n        //create the offsets for position and create the roomsize\r\n        const offset = [pos[0] - 1, pos[1]]\r\n        const roomSize = this.randomSize(5,7)\r\n\r\n        const rowSpan = [offset[0], offset[0] + roomSize[1]]\r\n        const colSpan = [offset[1] - roomSize[1] + 1, offset[1]]\r\n\r\n        //the positions returned are the span of the element indices\r\n        const colPosition = this.searchLeftColPosition(rowSpan[0],colSpan)\r\n        const rowPosition = this.searchTopBottomRowPosition(rowSpan,pos[1] + 1)\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n\r\n        //create and place the final room\r\n        const room = new Room(rowSize, colSize)\r\n        const position = [rowPosition[0], colPosition[0]]\r\n\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition(position)\r\n        return room\r\n    }\r\n    //top logic \r\n    placeTop(pos,dir){\r\n        //create the offsets for position and create the roomsize\r\n        const offset = [pos[0] + 1, pos[1]]\r\n        const roomSize = this.randomSize(5,7)\r\n\r\n        const rowSpan = [offset[0] - roomSize[1], offset[0]]\r\n        const colSpan = [offset[1], offset[1] + roomSize[1]]\r\n\r\n        //the positions returned are the span of the element indices\r\n        const rowPosition = this.searchTopRowPosition(colSpan[0],rowSpan)\r\n        const colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0])\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n\r\n        const room = new Room(rowSize, colSize)\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition([rowPosition[0], colPosition[0]])\r\n        return room\r\n    }\r\n\r\n    searchLeftRightPosition(colSpan, rowIdx){\r\n        var t = Math.abs(colSpan[0])\r\n        var b = Math.abs(colSpan[1])\r\n        //the span of the rows\r\n        var span = Math.abs(t-b)\r\n        //offset by half\r\n        t = t - Math.floor(span/3)\r\n        b = b - Math.floor(span/3)\r\n        t = Math.abs(t)\r\n        b = Math.abs(b)\r\n        rowIdx = Math.abs(rowIdx)\r\n        var counter = 0\r\n\r\n        //search both top and bottom for a good offset\r\n        if(this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false){\r\n            return [t,b]\r\n        }\r\n        //quarters\r\n        else{\r\n            while(this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false && counter < 3){\r\n                var topQuartile = Math.ceil((span/4) + t)\r\n                //because bottom is lower in count...\r\n                var bottomQuartile = Math.ceil(b - (span/4))\r\n                if(this.board[rowIdx][topQuartile].filled == true && this.board[rowIdx][bottomQuartile].filled == true){\r\n                    return [topQuartile, bottomQuartile]\r\n                }\r\n                //could be more complex statements  depending on the dungeon I decide\r\n                else{\r\n                    t = Math.ceil((span/4) + t) + 1\r\n                    b = Math.ceil(b - (span/4)) - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    searchTopRowPosition(colIndex, rowSpan){\r\n        var l = Math.abs(Math.floor(rowSpan[0]))\r\n        var r = Math.abs(Math.floor(rowSpan[1]))\r\n        var span = Math.abs(l-r)\r\n        var counter = 0\r\n        //if the index at l is not filled then you're fine, return \r\n        if(this.board[l][colIndex].filled == false){\r\n            return [l,r]\r\n        }\r\n        //else if its a bad index binary search for a good one unless there isn'l one\r\n        else{\r\n            while(this.board[l][colIndex].filled == true && counter < 3){\r\n                console.log('Top row is readjusting...')\r\n                var half = Math.floor(l + (span/4))\r\n                if(this.board[half][colIndex].filled == false){\r\n                    return [half,r]\r\n                }\r\n                else{\r\n                    span = half + 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    searchBottomRowPosition(colIndex, rowSpan){\r\n        var l = rowSpan[0]\r\n        var r = rowSpan[1]\r\n        var span = Math.abs(l-r)\r\n        var counter = 0\r\n        //if the index at l is not filled then you're fine, return \r\n        if(this.board[r][colIndex].filled == false){\r\n            return [l,r]\r\n        }\r\n        //else if its a bad index binary search for a good one unless there isn'l one\r\n        else{\r\n            while(this.board[l][colIndex].filled == true && counter < 3){\r\n                var half = Math.floor(r - (span/4))\r\n                console.log('Bottom row is readjusting...')\r\n                if(this.board[half][colIndex].filled == false){\r\n                    return [half,r]\r\n                }\r\n                else{\r\n                    span = half - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    //bottom room logic\r\n\r\n    placeBottom(pos,dir){\r\n        //create the offsets for position and create the roomsize\r\n        const offset = [pos[0] , pos[1]]\r\n        const roomSize = this.randomSize(5,7)\r\n\r\n        const rowSpan = [offset[0], offset[0] + roomSize[0]]\r\n        const colSpan = [offset[1], offset[1] + roomSize[1]]\r\n\r\n        //the positions returned are the span of the element indices\r\n        const rowPosition = this.searchTopRowPosition(colSpan[0],rowSpan)\r\n        const colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0])\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n\r\n        const room = new Room(rowSize, colSize)\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition([rowPosition[0], colPosition[0]])\r\n        return room\r\n    }\r\n\r\n\r\n//where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\r\n    generateRooms(node){\r\n        const halls = node.halls\r\n        const len = halls.length\r\n        var rooms = []\r\n        let newRoom = null\r\n        for(var i = 0; i < len; i++){\r\n            switch(halls[i].direction){\r\n                case 'r':\r\n                    newRoom = this.placeRight(halls[i].position, 'l') \r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        node.removeCooridor(halls[i].direction)\r\n                    }\r\n                    break\r\n                case 'l':\r\n                    newRoom = this.placeLeft(halls[i].position,'r')\r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        node.removeCooridor(halls[i].direction)\r\n                    }\r\n                    break\r\n                case 't':\r\n                    newRoom = this.placeTop(halls[i].position,'b')\r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        node.removeCooridor(halls[i].direction)\r\n                    }\r\n                    break\r\n                case 'b':\r\n                    newRoom = this.placeBottom(halls[i].position,'t')\r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        node.removeCooridor(halls[i].direction)\r\n                    }\r\n                    break\r\n                default:\r\n                    break\r\n            }\r\n        }\r\n        return rooms\r\n    }\r\n\r\n    generateHalls(num){\r\n        var hallDirections = ['l','r','t','b']\r\n        var randomDirs = []\r\n        var counter = num\r\n        while(counter > -1){\r\n            var idx = Math.floor((Math.random() * (hallDirections.length)) + 0)\r\n            randomDirs.push(hallDirections[idx])\r\n            hallDirections.splice(idx, 1)\r\n            counter -= 1\r\n        }\r\n        return randomDirs\r\n    }\r\n\r\n    randomSize(min, max){\r\n        var length = Math.floor((Math.random() * max) + min);\r\n        var width = Math.floor((Math.random() * max) + min);\r\n        const arr = [length, width]\r\n        return arr\r\n    }\r\n    \r\n    placeRoom(room){\r\n        //where position is based on row, col for map\r\n        var rowLength = room.width\r\n        var colLength = room.height\r\n        for(var i = 0; i < rowLength; i++){\r\n            for(var j = 0; j < colLength; j++){\r\n                var row = room.contents[i][j].position[0]\r\n                var col = room.contents[i][j].position[1]\r\n                if(this.board[row][col].type !== 'H')\r\n                {\r\n                    this.board[row][col] = room.contents[i][j]\r\n                    this.board[row][col].filled = true\r\n                }\r\n                else{\r\n                    this.board[row][col].filled = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    get contents(){\r\n        return this.board;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _readOnlyError from \"@babel/runtime-corejs2/helpers/esm/readOnlyError\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { Room, Node } from './room';\n\nvar Map =\n/*#__PURE__*/\nfunction () {\n  function Map(boardWidth, boardlength) {\n    _classCallCheck(this, Map);\n\n    //describes the boards with relative to amount of squares\n    this.width = boardWidth;\n    this.height = boardlength;\n    this.clearedBoard = []; //initialize the board with a clear state\n\n    this.clear();\n    this.board = this.clearedBoard;\n    this.roomCounter = 8;\n    this.createRooms(this.roomCounter);\n  }\n\n  _createClass(Map, [{\n    key: \"clear\",\n    value: function clear() {\n      for (var i = 0; i < this.height; i++) {\n        var arr = [];\n\n        for (var j = 0; j < this.width; j++) {\n          var emptyNodes = new Node('-', [i, j]);\n          arr.push(emptyNodes);\n        }\n\n        this.clearedBoard.push(arr);\n      }\n    }\n  }, {\n    key: \"createRooms\",\n    value: function createRooms(roomNumber) {\n      var roomCount = roomNumber;\n      var randomSize = this.randomSize(5, 7);\n      var roomNode = new Room(randomSize[0], randomSize[1]); // //create some halls\n\n      var halls = this.generateHalls(2); //initialize queue\n\n      var position = [25, 40];\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        roomNode.buildCooridor(halls[i]);\n      }\n\n      roomNode.changePosition(position);\n      roomNode.visited = true;\n      this.placeRoom(roomNode);\n      var queue = [];\n      queue.push(roomNode);\n      var randomCount = 5;\n\n      while (queue.length) {\n        var node = queue.shift(0);\n\n        if (node) {\n          var rooms = this.generateRooms(node);\n\n          for (var i = 0; i < rooms.length; i++) {\n            this.placeRoom(rooms[i]);\n            queue.push(rooms[i]);\n          }\n\n          randomCount -= 1;\n        }\n\n        randomCount -= 1;\n      }\n    } //methods for the right\n\n  }, {\n    key: \"searchRightColPosition\",\n    value: function searchRightColPosition(rowIdx, colSpan) {\n      var l = colSpan[0];\n      var r = colSpan[1];\n      var span = r - l;\n      var counter = 0; //if the index is not filled then you're fine, return r\n\n      if (this.board[rowIdx][r].filled == false) {\n        return [l, r];\n      } //else if its a bad index binary search for a good one unless there isn't one\n      else {\n          while (this.board[rowIdx][r].filled == true && counter < 3) {\n            var half = Math.floor(span / 2 + l);\n\n            if (this.board[rowIdx][half].filled == false) {\n              return [l, half];\n            } else {\n              span = half - 1;\n            }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    } //shared method for both left and right\n\n  }, {\n    key: \"searchTopBottomRowPosition\",\n    value: function searchTopBottomRowPosition(rowSpan, colIdx) {\n      //returns an array of the top and bottom indices for the rows\n      var t = rowSpan[0] + 1;\n      var b = rowSpan[1] + 1; //the span of the rows\n\n      var span = Math.abs(t - b); //offset by half\n\n      t = t - Math.floor(span / 3);\n\n      if (t < 0) {\n        t = 0;\n      }\n\n      b = b - Math.floor(span / 3);\n      var counter = 0; //search both top and bottom for a good offset\n\n      if (this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false) {\n        return [t, b];\n      } //quarters\n      else {\n          while (this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false && counter < 3) {\n            var topQuartile = Math.ceil(span / 4 + t); //because bottom is lower in count...\n\n            var bottomQuartile = Math.ceil(b - span / 4);\n\n            if (this.board[topQuartile][colIdx].filled == true && this.board[bottomQuartile][colIdx].filled == true) {\n              return [topQuartile, bottomQuartile];\n            } //could be more complex statements  depending on the dungeon I decide\n            else {\n                t = Math.ceil(span / 4 + t) + 1;\n                b = Math.ceil(b - span / 4) - 1;\n              }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    }\n  }, {\n    key: \"placeRight\",\n    value: function placeRight(pos, dir) {\n      //need to account for the offset from the non filled room\n      pos = [pos[0] - 1, pos[1]];\n      var roomSize = this.randomSize(5, 7);\n      var rowSpan = [pos[0], pos[0] + roomSize[0]];\n      var colSpan = [pos[1], pos[1] + roomSize[1]]; //the positions returned are the span of the element indices\n\n      var colPosition = this.searchRightColPosition(pos[0], colSpan); //add 1 to cols to avoid looking at the hall's positions\n\n      var rowPosition = this.searchTopBottomRowPosition(rowSpan, pos[1] + 1);\n\n      if (rowSize < 4 || colSize < 4 || rowPosition == null || colPosition == null) {\n        return null;\n      } //position from the top left\n\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]);\n      var room = new Room(rowSize, colSize); //position the room\n\n      var newPosition = [rowPosition[0], colPosition[0]];\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == dir || this.roomCounter == 0) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n        this.roomCounter -= 1;\n      }\n\n      room.changePosition(newPosition);\n      return room;\n    } //Methods for the left\n\n  }, {\n    key: \"searchLeftColPosition\",\n    value: function searchLeftColPosition(rowIdx, colSpan) {\n      var l = Math.abs(Math.floor(colSpan[0]));\n      var r = Math.abs(Math.floor(colSpan[1]));\n      var span = Math.abs(r - l);\n      var counter = 0; //if the index at l is not filled then you're fine, return\n\n      try {\n        if (this.board[rowIdx][l].filled == false) {\n          return [l, r];\n        } //else if its a bad index binary search for a good one unless there isn't one\n        else {\n            while (this.board[rowIdx][r].filled == true && counter < 3) {\n              var half = Math.floor(span / 4 + l);\n\n              if (this.board[rowIdx][half].filled == false) {\n                return [l, half];\n              } else {\n                span = (_readOnlyError(\"span\"), half - 1);\n              }\n\n              counter += 1;\n            }\n          }\n\n        return null;\n      } catch (e) {\n        console.log(rowIdx, l, r);\n      }\n    }\n  }, {\n    key: \"placeLeft\",\n    value: function placeLeft(pos, dir) {\n      //create the offsets for position and create the roomsize\n      var offset = [pos[0] - 1, pos[1]];\n      var roomSize = this.randomSize(5, 7);\n      var rowSpan = [offset[0], offset[0] + roomSize[1]];\n      var colSpan = [offset[1] - roomSize[1] + 1, offset[1]]; //the positions returned are the span of the element indices\n\n      var colPosition = this.searchLeftColPosition(rowSpan[0], colSpan);\n      var rowPosition = this.searchTopBottomRowPosition(rowSpan, pos[1] + 1);\n\n      if (rowSize < 4 || colSize < 4 || rowPosition == null || colPosition == null) {\n        return null;\n      }\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]); //create and place the final room\n\n      var room = new Room(rowSize, colSize);\n      var position = [rowPosition[0], colPosition[0]];\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == dir || this.roomCounter == 0) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n        this.roomCounter -= 1;\n      }\n\n      room.changePosition(position);\n      return room;\n    } //top logic \n\n  }, {\n    key: \"placeTop\",\n    value: function placeTop(pos, dir) {\n      //create the offsets for position and create the roomsize\n      var offset = [pos[0] + 1, pos[1]];\n      var roomSize = this.randomSize(5, 7);\n      var rowSpan = [offset[0] - roomSize[1], offset[0]];\n      var colSpan = [offset[1], offset[1] + roomSize[1]]; //the positions returned are the span of the element indices\n\n      var rowPosition = this.searchTopRowPosition(colSpan[0], rowSpan);\n      var colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0]);\n\n      if (rowSize < 4 || colSize < 4 || rowPosition == null || colPosition == null) {\n        return null;\n      }\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]);\n      var room = new Room(rowSize, colSize);\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == dir || this.roomCounter == 0) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n        this.roomCounter -= 1;\n      }\n\n      room.changePosition([rowPosition[0], colPosition[0]]);\n      return room;\n    }\n  }, {\n    key: \"searchLeftRightPosition\",\n    value: function searchLeftRightPosition(colSpan, rowIdx) {\n      var t = Math.abs(colSpan[0]);\n      var b = Math.abs(colSpan[1]); //the span of the rows\n\n      var span = Math.abs(t - b); //offset by half\n\n      t = t - Math.floor(span / 3);\n      b = b - Math.floor(span / 3);\n      t = Math.abs(t);\n      b = Math.abs(b);\n      rowIdx = Math.abs(rowIdx);\n      var counter = 0; //search both top and bottom for a good offset\n\n      if (this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false) {\n        return [t, b];\n      } //quarters\n      else {\n          while (this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false && counter < 3) {\n            var topQuartile = Math.ceil(span / 4 + t); //because bottom is lower in count...\n\n            var bottomQuartile = Math.ceil(b - span / 4);\n\n            if (this.board[rowIdx][topQuartile].filled == true && this.board[rowIdx][bottomQuartile].filled == true) {\n              return [topQuartile, bottomQuartile];\n            } //could be more complex statements  depending on the dungeon I decide\n            else {\n                t = Math.ceil(span / 4 + t) + 1;\n                b = Math.ceil(b - span / 4) - 1;\n              }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    }\n  }, {\n    key: \"searchTopRowPosition\",\n    value: function searchTopRowPosition(colIndex, rowSpan) {\n      var l = Math.abs(Math.floor(rowSpan[0]));\n      var r = Math.abs(Math.floor(rowSpan[1]));\n      var span = Math.abs(l - r);\n      var counter = 0; //if the index at l is not filled then you're fine, return \n\n      if (this.board[l][colIndex].filled == false) {\n        return [l, r];\n      } //else if its a bad index binary search for a good one unless there isn'l one\n      else {\n          while (this.board[l][colIndex].filled == true && counter < 3) {\n            var half = Math.floor(l + span / 2 + 1);\n\n            if (this.board[half][colIndex].filled == false) {\n              return [half, r];\n            } else {\n              span = half + 1;\n              console.log('Changing Top Span');\n            }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    }\n  }, {\n    key: \"searchBottomRowPosition\",\n    value: function searchBottomRowPosition(colIndex, rowSpan) {\n      var l = rowSpan[0];\n      var r = rowSpan[1];\n      var span = Math.abs(l - r);\n      var counter = 0; //if the index at l is not filled then you're fine, return \n\n      if (this.board[r][colIndex].filled == false) {\n        return [l, r];\n      } //else if its a bad index binary search for a good one unless there isn'l one\n      else {\n          while (this.board[l][colIndex].filled == true && counter < 3) {\n            var half = Math.floor(r - span / 4);\n\n            if (this.board[half][colIndex].filled == false) {\n              return [half, r];\n            } else {\n              span = half - 1;\n            }\n\n            counter += 1;\n          }\n        }\n\n      return null;\n    } //bottom room logic\n\n  }, {\n    key: \"placeBottom\",\n    value: function placeBottom(pos, dir) {\n      //create the offsets for position and create the roomsize\n      var offset = [pos[0], pos[1]];\n      var roomSize = this.randomSize(5, 7);\n      var rowSpan = [offset[0], offset[0] + roomSize[0]];\n      var colSpan = [offset[1], offset[1] + roomSize[1]]; //the positions returned are the span of the element indices\n\n      var rowPosition = this.searchBottomRowPosition(colSpan[0], rowSpan);\n      var colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0]);\n\n      if (rowSize < 4 || colSize < 4 || rowPosition == null || colPosition == null) {\n        return null;\n      }\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]);\n      var room = new Room(rowSize, colSize);\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == dir || this.roomCounter == 0) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n        this.roomCounter -= 1;\n      }\n\n      room.changePosition([rowPosition[0], colPosition[0]]);\n      return room;\n    } //where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\n\n  }, {\n    key: \"generateRooms\",\n    value: function generateRooms(node) {\n      var halls = node.halls;\n      var len = halls.length;\n      var rooms = [];\n      var removedHalls = [];\n      var newRoom = null;\n\n      for (var i = 0; i < len; i++) {\n        switch (halls[i].direction) {\n          case 'r':\n            newRoom = this.placeRight(halls[i].position, 'l');\n\n            if (newRoom) {\n              newRoom.parentHall = halls[i];\n              rooms.push(newRoom);\n            } else {\n              //remove the cooridor because it's not viable\n              this.roomCounter += 1;\n              removedHalls.push(halls[i].position);\n            }\n\n            break;\n\n          case 'l':\n            newRoom = this.placeLeft(halls[i].position, 'r');\n\n            if (newRoom) {\n              newRoom.parentHall = halls[i];\n              rooms.push(newRoom);\n            } else {\n              //remove the cooridor because it's not viable\n              this.roomCounter += 1;\n              removedHalls.push(halls[i].position);\n            }\n\n            break;\n\n          case 't':\n            newRoom = this.placeTop(halls[i].position, 'b');\n\n            if (newRoom) {\n              newRoom.parentHall = halls[i];\n              rooms.push(newRoom);\n            } else {\n              //remove the cooridor because it's not viable\n              this.roomCounter += 1;\n              removedHalls.push(halls[i].position);\n            }\n\n            break;\n\n          case 'b':\n            newRoom = this.placeBottom(halls[i].position, 't');\n\n            if (newRoom) {\n              newRoom.parentHall = halls[i];\n              rooms.push(newRoom);\n            } else {\n              //remove the cooridor because it's not viable\n              this.roomCounter += 1;\n              removedHalls.push(halls[i].position);\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      for (var i = 0; i < removedHalls.length; i++) {\n        var row = removedHalls[i][0];\n        var col = removedHalls[i][1];\n        this.board[row][col] = new Node('-', [row, col]);\n      }\n\n      return rooms;\n    }\n  }, {\n    key: \"generateHalls\",\n    value: function generateHalls(num) {\n      var hallDirections = ['l', 'r', 't', 'b'];\n      var randomDirs = [];\n      var counter = num;\n\n      while (counter > -1) {\n        var idx = Math.floor(Math.random() * hallDirections.length + 0);\n        randomDirs.push(hallDirections[idx]);\n        hallDirections.splice(idx, 1);\n        counter -= 1;\n      }\n\n      return randomDirs;\n    }\n  }, {\n    key: \"randomSize\",\n    value: function randomSize(min, max) {\n      var length = Math.floor(Math.random() * max + min);\n      var width = Math.floor(Math.random() * max + min);\n      var arr = [length, width];\n      return arr;\n    }\n  }, {\n    key: \"placeRoom\",\n    value: function placeRoom(room) {\n      //where position is based on row, col for map\n      var rowLength = room.width;\n      var colLength = room.height;\n\n      for (var i = 0; i < rowLength; i++) {\n        for (var j = 0; j < colLength; j++) {\n          var row = room.contents[i][j].position[0];\n          var col = room.contents[i][j].position[1];\n\n          if (this.board[row][col].type !== 'H') {\n            this.board[row][col] = room.contents[i][j];\n            this.board[row][col].filled = true;\n          } else {\n            this.board[row][col].filled = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"contents\",\n    get: function get() {\n      return this.board;\n    }\n  }]);\n\n  return Map;\n}();\n\nexport default Map;","map":{"version":3,"sources":["D:\\Programming\\Dungeon Crawler\\pages\\map.js"],"names":["Room","Node","Map","boardWidth","boardlength","width","height","clearedBoard","clear","board","roomCounter","createRooms","i","arr","j","emptyNodes","push","roomNumber","roomCount","randomSize","roomNode","halls","generateHalls","position","length","buildCooridor","changePosition","visited","placeRoom","queue","randomCount","node","shift","rooms","generateRooms","rowIdx","colSpan","l","r","span","counter","filled","half","Math","floor","rowSpan","colIdx","t","b","abs","topQuartile","ceil","bottomQuartile","pos","dir","roomSize","colPosition","searchRightColPosition","rowPosition","searchTopBottomRowPosition","rowSize","colSize","room","newPosition","e","console","log","offset","searchLeftColPosition","searchTopRowPosition","searchLeftRightPosition","colIndex","searchBottomRowPosition","len","removedHalls","newRoom","direction","placeRight","parentHall","placeLeft","placeTop","placeBottom","row","col","num","hallDirections","randomDirs","idx","random","splice","min","max","rowLength","colLength","contents","type"],"mappings":"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","sourcesContent":["import {Room, Node} from './room'\r\n\r\nclass Map{\r\n    constructor(boardWidth, boardlength){\r\n        //describes the boards with relative to amount of squares\r\n        this.width = boardWidth;\r\n        this.height = boardlength;\r\n        this.clearedBoard = [];\r\n        //initialize the board with a clear state\r\n        this.clear()\r\n        this.board = this.clearedBoard\r\n        this.roomCounter = 8\r\n        this.createRooms(this.roomCounter)\r\n    }\r\n\r\n    clear(){\r\n        for(var i = 0; i < this.height; i++){\r\n            let arr = []\r\n            for(var j = 0; j < this.width; j++){\r\n                var emptyNodes = new Node('-', [i,j])\r\n                arr.push(emptyNodes)\r\n            }\r\n            this.clearedBoard.push(arr)\r\n        }\r\n    }\r\n    \r\n    createRooms(roomNumber){\r\n\r\n        var roomCount = roomNumber\r\n        var randomSize = this.randomSize(5, 7)\r\n        var roomNode = new Room(randomSize[0], randomSize[1])\r\n        // //create some halls\r\n        var halls = this.generateHalls(2)\r\n        //initialize queue\r\n        var position = [25,40]\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            roomNode.buildCooridor(halls[i])\r\n        }\r\n        roomNode.changePosition(position)\r\n        roomNode.visited = true\r\n\r\n        this.placeRoom(roomNode)\r\n\r\n        var queue = []\r\n        queue.push(roomNode)\r\n        var randomCount = 5\r\n        while(queue.length){\r\n            var node = queue.shift(0)\r\n            if(node)\r\n            {\r\n                var rooms = this.generateRooms(node)\r\n                for(var i = 0; i < rooms.length; i++){\r\n                    this.placeRoom(rooms[i])\r\n                    queue.push(rooms[i])\r\n                }\r\n                randomCount -= 1\r\n            }\r\n            randomCount -= 1\r\n        }\r\n\r\n\r\n    }\r\n//methods for the right\r\n    searchRightColPosition(rowIdx, colSpan){\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n        var span = r - l\r\n        var counter = 0\r\n        //if the index is not filled then you're fine, return r\r\n        if(this.board[rowIdx][r].filled == false){\r\n            return [l,r]\r\n        }\r\n        //else if its a bad index binary search for a good one unless there isn't one\r\n        else{\r\n            while(this.board[rowIdx][r].filled == true && counter < 3){\r\n                var half = Math.floor((span/2) + l)\r\n                if(this.board[rowIdx][half].filled == false){\r\n                    return [l,half]\r\n                }\r\n                else{\r\n                    span = half - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n    //shared method for both left and right\r\n    searchTopBottomRowPosition(rowSpan, colIdx){\r\n        //returns an array of the top and bottom indices for the rows\r\n        var t = rowSpan[0] + 1\r\n        var b = rowSpan[1] + 1\r\n        //the span of the rows\r\n        var span = Math.abs(t-b)\r\n        //offset by half\r\n        t = t - Math.floor(span/3)\r\n        if(t < 0){\r\n            t = 0\r\n        }\r\n        b = b - Math.floor(span/3)\r\n        var counter = 0\r\n\r\n        //search both top and bottom for a good offset\r\n        if(this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false){\r\n            return [t,b]\r\n        }\r\n        //quarters\r\n        else{\r\n            while(this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false && counter < 3){\r\n                var topQuartile = Math.ceil((span/4) + t)\r\n                //because bottom is lower in count...\r\n                var bottomQuartile = Math.ceil(b - (span/4))\r\n                if(this.board[topQuartile][colIdx].filled == true && this.board[bottomQuartile][colIdx].filled == true){\r\n                    return [topQuartile, bottomQuartile]\r\n                }\r\n                //could be more complex statements  depending on the dungeon I decide\r\n                else{\r\n                    t = Math.ceil((span/4) + t) + 1\r\n                    b = Math.ceil(b - (span/4)) - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    placeRight(pos,dir){\r\n        //need to account for the offset from the non filled room\r\n        pos = [pos[0] - 1, pos[1]]\r\n        var roomSize = this.randomSize(5,7)\r\n        var rowSpan = [pos[0], pos[0] + roomSize[0]]\r\n        var colSpan = [pos[1], pos[1] + roomSize[1]]\r\n        //the positions returned are the span of the element indices\r\n        var colPosition = this.searchRightColPosition(pos[0],colSpan)\r\n        //add 1 to cols to avoid looking at the hall's positions\r\n        var rowPosition = this.searchTopBottomRowPosition(rowSpan,pos[1] + 1)\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        //position from the top left\r\n        var rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        var colSize = Math.abs(colPosition[1] - colPosition[0])\r\n        var room = new Room(rowSize, colSize)\r\n        //position the room\r\n        var newPosition = [rowPosition[0], colPosition[0]]\r\n        const halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition(newPosition)\r\n        return room\r\n    }\r\n\r\n    //Methods for the left\r\n    searchLeftColPosition(rowIdx,colSpan){\r\n        const l = Math.abs(Math.floor(colSpan[0]))\r\n        const r = Math.abs(Math.floor(colSpan[1]))\r\n        const span = Math.abs(r - l)\r\n        var counter = 0\r\n        //if the index at l is not filled then you're fine, return\r\n        try{\r\n            if(this.board[rowIdx][l].filled == false){\r\n                return [l,r]\r\n            }\r\n            //else if its a bad index binary search for a good one unless there isn't one\r\n            else{\r\n                while(this.board[rowIdx][r].filled == true && counter < 3){\r\n                    var half = Math.floor((span/4) + l)\r\n                    if(this.board[rowIdx][half].filled == false){\r\n                        return [l,half]\r\n                    }\r\n                    else{\r\n                        span = half - 1\r\n                    }\r\n                    counter += 1\r\n                }\r\n            }\r\n            return null\r\n        }\r\n        catch(e){\r\n            console.log(rowIdx, l, r)\r\n        }\r\n\r\n    }\r\n    \r\n    placeLeft(pos,dir){\r\n        //create the offsets for position and create the roomsize\r\n        const offset = [pos[0] - 1, pos[1]]\r\n        const roomSize = this.randomSize(5,7)\r\n\r\n        const rowSpan = [offset[0], offset[0] + roomSize[1]]\r\n        const colSpan = [offset[1] - roomSize[1] + 1, offset[1]]\r\n\r\n        //the positions returned are the span of the element indices\r\n        const colPosition = this.searchLeftColPosition(rowSpan[0],colSpan)\r\n        const rowPosition = this.searchTopBottomRowPosition(rowSpan,pos[1] + 1)\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n\r\n        //create and place the final room\r\n        const room = new Room(rowSize, colSize)\r\n        const position = [rowPosition[0], colPosition[0]]\r\n\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition(position)\r\n        return room\r\n    }\r\n    //top logic \r\n    placeTop(pos,dir){\r\n        //create the offsets for position and create the roomsize\r\n        const offset = [pos[0] + 1, pos[1]]\r\n        const roomSize = this.randomSize(5,7)\r\n\r\n        const rowSpan = [offset[0] - roomSize[1], offset[0]]\r\n        const colSpan = [offset[1], offset[1] + roomSize[1]]\r\n\r\n        //the positions returned are the span of the element indices\r\n        const rowPosition = this.searchTopRowPosition(colSpan[0],rowSpan)\r\n        const colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0])\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n\r\n        const room = new Room(rowSize, colSize)\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition([rowPosition[0], colPosition[0]])\r\n        return room\r\n    }\r\n\r\n    searchLeftRightPosition(colSpan, rowIdx){\r\n        var t = Math.abs(colSpan[0])\r\n        var b = Math.abs(colSpan[1])\r\n        //the span of the rows\r\n        var span = Math.abs(t-b)\r\n        //offset by half\r\n        t = t - Math.floor(span/3)\r\n        b = b - Math.floor(span/3)\r\n        t = Math.abs(t)\r\n        b = Math.abs(b)\r\n        rowIdx = Math.abs(rowIdx)\r\n        var counter = 0\r\n\r\n        //search both top and bottom for a good offset\r\n        if(this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false){\r\n            return [t,b]\r\n        }\r\n        //quarters\r\n        else{\r\n            while(this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false && counter < 3){\r\n                var topQuartile = Math.ceil((span/4) + t)\r\n                //because bottom is lower in count...\r\n                var bottomQuartile = Math.ceil(b - (span/4))\r\n                if(this.board[rowIdx][topQuartile].filled == true && this.board[rowIdx][bottomQuartile].filled == true){\r\n                    return [topQuartile, bottomQuartile]\r\n                }\r\n                //could be more complex statements  depending on the dungeon I decide\r\n                else{\r\n                    t = Math.ceil((span/4) + t) + 1\r\n                    b = Math.ceil(b - (span/4)) - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    searchTopRowPosition(colIndex, rowSpan){\r\n        var l = Math.abs(Math.floor(rowSpan[0]))\r\n        var r = Math.abs(Math.floor(rowSpan[1]))\r\n        var span = Math.abs(l-r)\r\n        var counter = 0\r\n        //if the index at l is not filled then you're fine, return \r\n        if(this.board[l][colIndex].filled == false){\r\n            return [l,r]\r\n        }\r\n        //else if its a bad index binary search for a good one unless there isn'l one\r\n        else{\r\n            while(this.board[l][colIndex].filled == true && counter < 3){\r\n                var half = Math.floor(l + (span/2) + 1)\r\n                if(this.board[half][colIndex].filled == false){\r\n                    return [half,r]\r\n                }\r\n                else{\r\n                    span = half + 1\r\n                    console.log('Changing Top Span')\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    searchBottomRowPosition(colIndex, rowSpan){\r\n        var l = rowSpan[0]\r\n        var r = rowSpan[1]\r\n        var span = Math.abs(l-r)\r\n        var counter = 0\r\n        //if the index at l is not filled then you're fine, return \r\n        if(this.board[r][colIndex].filled == false){\r\n            return [l,r]\r\n        }\r\n        //else if its a bad index binary search for a good one unless there isn'l one\r\n        else{\r\n            while(this.board[l][colIndex].filled == true && counter < 3){\r\n                var half = Math.floor(r - (span/4))\r\n                if(this.board[half][colIndex].filled == false){\r\n                    return [half,r]\r\n                }\r\n                else{\r\n                    span = half - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    //bottom room logic\r\n\r\n    placeBottom(pos,dir){\r\n        //create the offsets for position and create the roomsize\r\n        const offset = [pos[0] , pos[1]]\r\n        const roomSize = this.randomSize(5,7)\r\n\r\n        const rowSpan = [offset[0], offset[0] + roomSize[0]]\r\n        const colSpan = [offset[1], offset[1] + roomSize[1]]\r\n\r\n        //the positions returned are the span of the element indices\r\n        const rowPosition = this.searchBottomRowPosition(colSpan[0],rowSpan)\r\n        const colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0])\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n\r\n        const room = new Room(rowSize, colSize)\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition([rowPosition[0], colPosition[0]])\r\n        return room\r\n    }\r\n\r\n\r\n//where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\r\n    generateRooms(node){\r\n        const halls = node.halls\r\n        const len = halls.length\r\n        var rooms = []\r\n        let removedHalls = []\r\n        let newRoom = null\r\n        for(var i = 0; i < len; i++){\r\n            switch(halls[i].direction){\r\n                case 'r':\r\n                    newRoom = this.placeRight(halls[i].position, 'l') \r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        removedHalls.push(halls[i].position)\r\n\r\n                    }\r\n                    break\r\n                case 'l':\r\n                    newRoom = this.placeLeft(halls[i].position,'r')\r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        removedHalls.push(halls[i].position)\r\n                    }\r\n                    break\r\n                case 't':\r\n                    newRoom = this.placeTop(halls[i].position,'b')\r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        removedHalls.push(halls[i].position)\r\n                    }\r\n                    break\r\n                case 'b':\r\n                    newRoom = this.placeBottom(halls[i].position,'t')\r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        removedHalls.push(halls[i].position)\r\n                    }\r\n                    break\r\n                default:\r\n                    break\r\n            }\r\n        }\r\n        for(var i = 0; i < removedHalls.length; i++){\r\n            var row = removedHalls[i][0]\r\n            var col = removedHalls[i][1]\r\n            this.board[row][col] = new Node('-', [row,col])\r\n        }\r\n        return rooms\r\n    }\r\n\r\n    generateHalls(num){\r\n        var hallDirections = ['l','r','t','b']\r\n        var randomDirs = []\r\n        var counter = num\r\n        while(counter > -1){\r\n            var idx = Math.floor((Math.random() * (hallDirections.length)) + 0)\r\n            randomDirs.push(hallDirections[idx])\r\n            hallDirections.splice(idx, 1)\r\n            counter -= 1\r\n        }\r\n        return randomDirs\r\n    }\r\n\r\n    randomSize(min, max){\r\n        var length = Math.floor((Math.random() * max) + min);\r\n        var width = Math.floor((Math.random() * max) + min);\r\n        const arr = [length, width]\r\n        return arr\r\n    }\r\n    \r\n    placeRoom(room){\r\n        //where position is based on row, col for map\r\n        var rowLength = room.width\r\n        var colLength = room.height\r\n        for(var i = 0; i < rowLength; i++){\r\n            for(var j = 0; j < colLength; j++){\r\n                var row = room.contents[i][j].position[0]\r\n                var col = room.contents[i][j].position[1]\r\n                if(this.board[row][col].type !== 'H')\r\n                {\r\n                    this.board[row][col] = room.contents[i][j]\r\n                    this.board[row][col].filled = true\r\n                }\r\n                else{\r\n                    this.board[row][col].filled = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    get contents(){\r\n        return this.board;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Map"]},"metadata":{},"sourceType":"module"}
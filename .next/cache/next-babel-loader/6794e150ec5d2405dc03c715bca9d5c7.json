{"ast":null,"code":"import _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport { Room, Node } from './room';\n\nvar Map =\n/*#__PURE__*/\nfunction () {\n  function Map(boardWidth, boardlength) {\n    _classCallCheck(this, Map);\n\n    //describes the boards with relative to amount of squares\n    this.width = boardWidth;\n    this.height = boardlength;\n    this.clearedBoard = []; //initialize the board with a clear state\n\n    this.clear();\n    this.board = this.clearedBoard;\n    this.roomCounter = 8;\n    this.createRooms(this.roomCounter);\n  }\n\n  _createClass(Map, [{\n    key: \"clear\",\n    value: function clear() {\n      for (var i = 0; i < this.height; i++) {\n        var arr = [];\n\n        for (var j = 0; j < this.width; j++) {\n          var emptyNodes = new Node('-', [i, j]);\n          arr.push(emptyNodes);\n        }\n\n        this.clearedBoard.push(arr);\n      }\n    }\n  }, {\n    key: \"createRooms\",\n    value: function createRooms(roomNumber) {\n      var roomCount = roomNumber;\n      var randomSize = [5, 7];\n      var roomNode = new Room(randomSize[0], randomSize[1]); // //create some halls\n\n      var halls = this.generateHalls(2); //initialize queue\n\n      var position = [25, 40];\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        roomNode.buildCooridor(halls[i]);\n      }\n\n      roomNode.changePosition(position);\n      roomNode.visited = true;\n      this.placeRoom(roomNode);\n      var queue = [];\n      queue.push(roomNode);\n      var randomCount = 5;\n\n      while (queue.length) {\n        var node = queue.shift(0);\n\n        if (node) {\n          var rooms = this.generateRooms(node);\n\n          for (var i = 0; i < rooms.length; i++) {\n            this.placeRoom(rooms[i]);\n            queue.push(rooms[i]);\n          }\n        }\n\n        return;\n      }\n    } //methods for the right\n\n  }, {\n    key: \"rightColPositions\",\n    value: function rightColPositions(callback) {\n      var colSpan = arguments[0];\n      var rowIdx = arguments[1];\n      var board = arguments[2];\n      var l = colSpan[0];\n      var r = colSpan[1];\n\n      try {\n        if (board[rowIdx][r].filled == false) {\n          return [l, r];\n        } else {\n          return null;\n        }\n      } catch (e) {\n        console.log('column position is null with', l, r);\n      }\n    } //shared method for both left and right\n\n  }, {\n    key: \"rightRowPositions\",\n    value: function rightRowPositions(callback) {\n      var rowSpan = arguments[0];\n      var colIdx = arguments[1] + 1;\n      var board = arguments[2]; //get top and bottom\n\n      var t = rowSpan[0];\n      var b = rowSpan[1]; //create copies to check reduction bounds\n\n      var originalT = t;\n      var originalB = b;\n      var counter = 0;\n      var span = Math.abs(t - b); //reduce by more than a half because of offsets\n\n      t = t - Math.floor(span / 3);\n      b = b - Math.floor(span / 3); //update the span\n\n      span = Math.abs(t - b);\n      board[24][45].filled = true;\n      board[25][45].filled = true;\n      board[26][45].filled = true;\n\n      try {\n        //if nothing has to be done return the positions as is\n        if (board[t][colIdx].filled == false && board[b][colIdx].filled == false) {\n          console.log('returning original');\n          return [t, b];\n        } else {\n          while ((board[t][colIdx].filled == true || board[b][colIdx].filled == true || board[t][colIdx - 1].type !== 'H' || board[b][colIdx - 1].type !== 'H') && counter < 3) {\n            console.log('reducing'); //top is occupied, reduce by a quarter, usually just 1 because rooms are small right now\n\n            if (board[t][colIdx].filled == true) {\n              t = t + Math.floor(span / 4);\n            } //bot is occupied, reduce by a quarter, usually just 1 because rooms are small right now\n\n\n            if (board[b][colIdx].filled == true) {\n              b = b - Math.floor(span / 4);\n            } //return the updated positions if the positions are not filled\n\n\n            if (board[t][colIdx].filled == false && board[b][colIdx].filled == false && originalT >= t && originalB <= b) {\n              console.log(originalT, t);\n              return [t, b];\n            } //update the span\n\n\n            span = Math.abs(t - b); //update counter\n\n            counter += 1;\n          }\n        }\n      } catch (e) {\n        console.log('row position is null with top:${t} and bottom: ${b}');\n        return null;\n      }\n\n      return null;\n    } //goes to generateRoom for generateRooms()\n\n  }, {\n    key: \"generateRoom\",\n    value: function generateRoom(rowcallback, colcallback, rowSpan, colSpan, direction) {\n      var board = this.board;\n      var rowPosition = rowcallback(rowSpan, colSpan[0], board);\n      var colPosition = colcallback(colSpan, rowSpan[0], board);\n\n      if (rowPosition == null || colPosition == null) {\n        console.log('The positions are ', rowPosition, colPosition);\n        return null;\n      }\n\n      var rowSize = Math.abs(rowPosition[1] - rowPosition[0]);\n      var colSize = Math.abs(colPosition[1] - colPosition[0]);\n      var position = [rowPosition[0], colPosition[0]];\n      var room = new Room(rowSize, colSize);\n      var halls = this.generateHalls(2);\n\n      for (var i = 0; i < halls.length; i++) {\n        if (halls[i] == direction) {\n          continue;\n        }\n\n        room.buildCooridor(halls[i]);\n      }\n\n      room.changePosition(position);\n      return room;\n    } //where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\n\n  }, {\n    key: \"generateRooms\",\n    value: function generateRooms(node) {\n      var halls = node.halls;\n      var len = halls.length;\n      var rooms = [];\n      var newRoom = null;\n\n      for (var i = 0; i < len; i++) {\n        var roomSize = this.randomSize(5, 7);\n        var rowStart = halls[i].position[0];\n        var colStart = halls[i].position[1];\n\n        switch (halls[i].direction) {\n          case 'r':\n            //the -1 is to offset the side on the top\n            var rowSpan = [rowStart - 1, rowStart + roomSize[0] - 1]; //dont need to offset the col because the hall connect what would be the blank space\n\n            var colSpan = [colStart, colStart + roomSize[1]];\n\n            try {\n              newRoom = this.generateRoom(this.rightRowPositions, this.rightColPositions, rowSpan, colSpan, 'l');\n\n              if (newRoom == null) {\n                continue;\n              }\n\n              rooms.push(newRoom);\n            } catch (e) {\n              console.log('room is null');\n            }\n\n            break;\n\n          case 'l':\n            break;\n\n          case 't':\n            break;\n\n          case 'b':\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return rooms;\n    }\n  }, {\n    key: \"generateHalls\",\n    value: function generateHalls(num) {\n      var hallDirections = ['l', 'r', 't', 'b'];\n      var randomDirs = [];\n      var counter = num;\n\n      while (counter > -1) {\n        var idx = Math.floor(Math.random() * hallDirections.length + 0);\n        randomDirs.push(hallDirections[idx]);\n        hallDirections.splice(idx, 1);\n        counter -= 1;\n      }\n\n      return randomDirs;\n    }\n  }, {\n    key: \"randomSize\",\n    value: function randomSize(min, max) {\n      var length = Math.floor(Math.random() * max + min);\n      var width = Math.floor(Math.random() * max + min);\n      var arr = [length, width];\n      return arr;\n    }\n  }, {\n    key: \"placeRoom\",\n    value: function placeRoom(room) {\n      //where position is based on row, col for map\n      var rowLength = room.width;\n      var colLength = room.height;\n\n      for (var i = 0; i < rowLength; i++) {\n        for (var j = 0; j < colLength; j++) {\n          var row = room.contents[i][j].position[0];\n          var col = room.contents[i][j].position[1];\n\n          if (this.board[row][col].type !== 'H') {\n            this.board[row][col] = room.contents[i][j];\n            this.board[row][col].filled = true;\n          } else {\n            this.board[row][col].filled = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"contents\",\n    get: function get() {\n      return this.board;\n    }\n  }]);\n\n  return Map;\n}();\n\nexport default Map;","map":{"version":3,"sources":["D:\\Programming\\Dungeon Crawler\\pages\\map.js"],"names":["Room","Node","Map","boardWidth","boardlength","width","height","clearedBoard","clear","board","roomCounter","createRooms","i","arr","j","emptyNodes","push","roomNumber","roomCount","randomSize","roomNode","halls","generateHalls","position","length","buildCooridor","changePosition","visited","placeRoom","queue","randomCount","node","shift","rooms","generateRooms","callback","colSpan","arguments","rowIdx","l","r","filled","e","console","log","rowSpan","colIdx","t","b","originalT","originalB","counter","span","Math","abs","floor","type","rowcallback","colcallback","direction","rowPosition","colPosition","rowSize","colSize","room","len","newRoom","roomSize","rowStart","colStart","generateRoom","rightRowPositions","rightColPositions","num","hallDirections","randomDirs","idx","random","splice","min","max","rowLength","colLength","row","contents","col"],"mappings":";;AAAA,SAAQA,IAAR,EAAcC,IAAd,QAAyB,QAAzB;;IAEMC,G;;;AACF,eAAYC,UAAZ,EAAwBC,WAAxB,EAAoC;AAAA;;AAChC;AACA,SAAKC,KAAL,GAAaF,UAAb;AACA,SAAKG,MAAL,GAAcF,WAAd;AACA,SAAKG,YAAL,GAAoB,EAApB,CAJgC,CAKhC;;AACA,SAAKC,KAAL;AACA,SAAKC,KAAL,GAAa,KAAKF,YAAlB;AACA,SAAKG,WAAL,GAAmB,CAAnB;AACA,SAAKC,WAAL,CAAiB,KAAKD,WAAtB;AACH;;;;4BAEM;AACH,WAAI,IAAIE,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,KAAKN,MAAxB,EAAgCM,CAAC,EAAjC,EAAoC;AAChC,YAAIC,GAAG,GAAG,EAAV;;AACA,aAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,KAAKT,KAAxB,EAA+BS,CAAC,EAAhC,EAAmC;AAC/B,cAAIC,UAAU,GAAG,IAAId,IAAJ,CAAS,GAAT,EAAc,CAACW,CAAD,EAAGE,CAAH,CAAd,CAAjB;AACAD,UAAAA,GAAG,CAACG,IAAJ,CAASD,UAAT;AACH;;AACD,aAAKR,YAAL,CAAkBS,IAAlB,CAAuBH,GAAvB;AACH;AACJ;;;gCAEWI,U,EAAW;AAEnB,UAAIC,SAAS,GAAGD,UAAhB;AACA,UAAIE,UAAU,GAAG,CAAC,CAAD,EAAG,CAAH,CAAjB;AACA,UAAIC,QAAQ,GAAG,IAAIpB,IAAJ,CAASmB,UAAU,CAAC,CAAD,CAAnB,EAAwBA,UAAU,CAAC,CAAD,CAAlC,CAAf,CAJmB,CAKnB;;AACA,UAAIE,KAAK,GAAG,KAAKC,aAAL,CAAmB,CAAnB,CAAZ,CANmB,CAOnB;;AACA,UAAIC,QAAQ,GAAG,CAAC,EAAD,EAAI,EAAJ,CAAf;AACA,UAAIF,KAAK,GAAG,KAAKC,aAAL,CAAmB,CAAnB,CAAZ;;AACA,WAAI,IAAIV,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGS,KAAK,CAACG,MAAzB,EAAiCZ,CAAC,EAAlC,EAAqC;AACjCQ,QAAAA,QAAQ,CAACK,aAAT,CAAuBJ,KAAK,CAACT,CAAD,CAA5B;AACH;;AACDQ,MAAAA,QAAQ,CAACM,cAAT,CAAwBH,QAAxB;AACAH,MAAAA,QAAQ,CAACO,OAAT,GAAmB,IAAnB;AAEA,WAAKC,SAAL,CAAeR,QAAf;AAEA,UAAIS,KAAK,GAAG,EAAZ;AACAA,MAAAA,KAAK,CAACb,IAAN,CAAWI,QAAX;AACA,UAAIU,WAAW,GAAG,CAAlB;;AACA,aAAMD,KAAK,CAACL,MAAZ,EAAmB;AACf,YAAIO,IAAI,GAAGF,KAAK,CAACG,KAAN,CAAY,CAAZ,CAAX;;AACA,YAAGD,IAAH,EACA;AACI,cAAIE,KAAK,GAAG,KAAKC,aAAL,CAAmBH,IAAnB,CAAZ;;AACA,eAAI,IAAInB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGqB,KAAK,CAACT,MAAzB,EAAiCZ,CAAC,EAAlC,EAAqC;AACjC,iBAAKgB,SAAL,CAAeK,KAAK,CAACrB,CAAD,CAApB;AACAiB,YAAAA,KAAK,CAACb,IAAN,CAAWiB,KAAK,CAACrB,CAAD,CAAhB;AACH;AACJ;;AACD;AACH;AAGJ,K,CACL;;;;sCACsBuB,Q,EAAS;AACvB,UAAIC,OAAO,GAAGC,SAAS,CAAC,CAAD,CAAvB;AACA,UAAIC,MAAM,GAAGD,SAAS,CAAC,CAAD,CAAtB;AACA,UAAI5B,KAAK,GAAG4B,SAAS,CAAC,CAAD,CAArB;AACA,UAAIE,CAAC,GAAGH,OAAO,CAAC,CAAD,CAAf;AACA,UAAII,CAAC,GAAGJ,OAAO,CAAC,CAAD,CAAf;;AAEA,UAAG;AACC,YAAG3B,KAAK,CAAC6B,MAAD,CAAL,CAAcE,CAAd,EAAiBC,MAAjB,IAA2B,KAA9B,EAAoC;AAChC,iBAAO,CAACF,CAAD,EAAGC,CAAH,CAAP;AACH,SAFD,MAGI;AACA,iBAAO,IAAP;AACH;AACJ,OAPD,CAQA,OAAME,CAAN,EAAQ;AACJC,QAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA2CL,CAA3C,EAA6CC,CAA7C;AACH;AACJ,K,CACD;;;;sCACkBL,Q,EAAS;AACvB,UAAIU,OAAO,GAAGR,SAAS,CAAC,CAAD,CAAvB;AACA,UAAIS,MAAM,GAAGT,SAAS,CAAC,CAAD,CAAT,GAAe,CAA5B;AACA,UAAI5B,KAAK,GAAG4B,SAAS,CAAC,CAAD,CAArB,CAHuB,CAIvB;;AACA,UAAIU,CAAC,GAAGF,OAAO,CAAC,CAAD,CAAf;AACA,UAAIG,CAAC,GAAGH,OAAO,CAAC,CAAD,CAAf,CANuB,CAOvB;;AACA,UAAII,SAAS,GAAGF,CAAhB;AACA,UAAIG,SAAS,GAAGF,CAAhB;AAEA,UAAIG,OAAO,GAAG,CAAd;AAEA,UAAIC,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASP,CAAC,GAACC,CAAX,CAAX,CAbuB,CAcvB;;AACAD,MAAAA,CAAC,GAAGA,CAAC,GAAGM,IAAI,CAACE,KAAL,CAAYH,IAAI,GAAC,CAAjB,CAAR;AACAJ,MAAAA,CAAC,GAAGA,CAAC,GAAGK,IAAI,CAACE,KAAL,CAAWH,IAAI,GAAC,CAAhB,CAAR,CAhBuB,CAiBvB;;AACAA,MAAAA,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASP,CAAC,GAAGC,CAAb,CAAP;AACAvC,MAAAA,KAAK,CAAC,EAAD,CAAL,CAAU,EAAV,EAAcgC,MAAd,GAAuB,IAAvB;AACAhC,MAAAA,KAAK,CAAC,EAAD,CAAL,CAAU,EAAV,EAAcgC,MAAd,GAAuB,IAAvB;AACAhC,MAAAA,KAAK,CAAC,EAAD,CAAL,CAAU,EAAV,EAAcgC,MAAd,GAAuB,IAAvB;;AACA,UAAG;AACC;AACA,YAAGhC,KAAK,CAACsC,CAAD,CAAL,CAASD,MAAT,EAAiBL,MAAjB,IAA2B,KAA3B,IAAoChC,KAAK,CAACuC,CAAD,CAAL,CAASF,MAAT,EAAiBL,MAAjB,IAA2B,KAAlE,EAAwE;AACpEE,UAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AACA,iBAAO,CAACG,CAAD,EAAGC,CAAH,CAAP;AACH,SAHD,MAII;AACA,iBAAM,CAAEvC,KAAK,CAACsC,CAAD,CAAL,CAASD,MAAT,EAAiBL,MAAjB,IAA2B,IAA3B,IAAmChC,KAAK,CAACuC,CAAD,CAAL,CAASF,MAAT,EAAiBL,MAAjB,IAA2B,IAA/D,IACAhC,KAAK,CAACsC,CAAD,CAAL,CAASD,MAAM,GAAC,CAAhB,EAAmBU,IAAnB,KAA4B,GAA5B,IAAmC/C,KAAK,CAACuC,CAAD,CAAL,CAASF,MAAM,GAAC,CAAhB,EAAmBU,IAAnB,KAA4B,GADhE,KAEAL,OAAO,GAAG,CAFhB,EAEkB;AACdR,YAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EADc,CAEd;;AACA,gBAAGnC,KAAK,CAACsC,CAAD,CAAL,CAASD,MAAT,EAAiBL,MAAjB,IAA2B,IAA9B,EAAmC;AAC/BM,cAAAA,CAAC,GAAGA,CAAC,GAAGM,IAAI,CAACE,KAAL,CAAWH,IAAI,GAAC,CAAhB,CAAR;AACH,aALa,CAMd;;;AACA,gBAAG3C,KAAK,CAACuC,CAAD,CAAL,CAASF,MAAT,EAAiBL,MAAjB,IAA2B,IAA9B,EAAmC;AAC/BO,cAAAA,CAAC,GAAGA,CAAC,GAAGK,IAAI,CAACE,KAAL,CAAWH,IAAI,GAAC,CAAhB,CAAR;AACH,aATa,CAUd;;;AACA,gBAAG3C,KAAK,CAACsC,CAAD,CAAL,CAASD,MAAT,EAAiBL,MAAjB,IAA2B,KAA3B,IAAoChC,KAAK,CAACuC,CAAD,CAAL,CAASF,MAAT,EAAiBL,MAAjB,IAA2B,KAA/D,IACCQ,SAAS,IAAIF,CAAb,IAAkBG,SAAS,IAAGF,CADlC,EACqC;AACjCL,cAAAA,OAAO,CAACC,GAAR,CAAYK,SAAZ,EAAuBF,CAAvB;AACA,qBAAO,CAACA,CAAD,EAAGC,CAAH,CAAP;AACH,aAfa,CAgBd;;;AACAI,YAAAA,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASP,CAAC,GAACC,CAAX,CAAP,CAjBc,CAkBd;;AACAG,YAAAA,OAAO,IAAI,CAAX;AACH;AACJ;AAEJ,OAhCD,CAiCA,OAAMT,CAAN,EAAQ;AACJC,QAAAA,OAAO,CAACC,GAAR,CAAY,qDAAZ;AACA,eAAO,IAAP;AACH;;AACD,aAAO,IAAP;AACH,K,CAED;;;;iCACaa,W,EAAaC,W,EAAab,O,EAAST,O,EAASuB,S,EAAU;AAC/D,UAAIlD,KAAK,GAAG,KAAKA,KAAjB;AACA,UAAMmD,WAAW,GAAGH,WAAW,CAACZ,OAAD,EAAUT,OAAO,CAAC,CAAD,CAAjB,EAAsB3B,KAAtB,CAA/B;AACA,UAAMoD,WAAW,GAAGH,WAAW,CAACtB,OAAD,EAAUS,OAAO,CAAC,CAAD,CAAjB,EAAsBpC,KAAtB,CAA/B;;AACA,UAAGmD,WAAW,IAAI,IAAf,IAAuBC,WAAW,IAAI,IAAzC,EAA8C;AAC1ClB,QAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ,EAAkCgB,WAAlC,EAA+CC,WAA/C;AACA,eAAO,IAAP;AACH;;AAED,UAAMC,OAAO,GAAGT,IAAI,CAACC,GAAL,CAASM,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAArC,CAAhB;AACA,UAAMG,OAAO,GAAGV,IAAI,CAACC,GAAL,CAASO,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAArC,CAAhB;AACA,UAAMtC,QAAQ,GAAG,CAACqC,WAAW,CAAC,CAAD,CAAZ,EAAiBC,WAAW,CAAC,CAAD,CAA5B,CAAjB;AAEA,UAAMG,IAAI,GAAG,IAAIhE,IAAJ,CAAS8D,OAAT,EAAkBC,OAAlB,CAAb;AACA,UAAM1C,KAAK,GAAG,KAAKC,aAAL,CAAmB,CAAnB,CAAd;;AACA,WAAI,IAAIV,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGS,KAAK,CAACG,MAAzB,EAAiCZ,CAAC,EAAlC,EAAqC;AACjC,YAAGS,KAAK,CAACT,CAAD,CAAL,IAAY+C,SAAf,EAA0B;AACtB;AACH;;AACDK,QAAAA,IAAI,CAACvC,aAAL,CAAmBJ,KAAK,CAACT,CAAD,CAAxB;AACH;;AAEDoD,MAAAA,IAAI,CAACtC,cAAL,CAAoBH,QAApB;AACA,aAAOyC,IAAP;AAEH,K,CAIL;;;;kCACkBjC,I,EAAK;AACf,UAAMV,KAAK,GAAGU,IAAI,CAACV,KAAnB;AACA,UAAM4C,GAAG,GAAG5C,KAAK,CAACG,MAAlB;AACA,UAAIS,KAAK,GAAG,EAAZ;AACA,UAAIiC,OAAO,GAAG,IAAd;;AACA,WAAI,IAAItD,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGqD,GAAnB,EAAwBrD,CAAC,EAAzB,EAA4B;AACxB,YAAIuD,QAAQ,GAAG,KAAKhD,UAAL,CAAgB,CAAhB,EAAkB,CAAlB,CAAf;AACA,YAAIiD,QAAQ,GAAG/C,KAAK,CAACT,CAAD,CAAL,CAASW,QAAT,CAAkB,CAAlB,CAAf;AACA,YAAI8C,QAAQ,GAAIhD,KAAK,CAACT,CAAD,CAAL,CAASW,QAAT,CAAkB,CAAlB,CAAhB;;AACA,gBAAOF,KAAK,CAACT,CAAD,CAAL,CAAS+C,SAAhB;AACI,eAAK,GAAL;AACI;AACA,gBAAId,OAAO,GAAG,CAACuB,QAAQ,GAAG,CAAZ,EAAeA,QAAQ,GAAGD,QAAQ,CAAC,CAAD,CAAnB,GAAyB,CAAxC,CAAd,CAFJ,CAGI;;AACA,gBAAI/B,OAAO,GAAG,CAACiC,QAAD,EAAYA,QAAQ,GAAGF,QAAQ,CAAC,CAAD,CAA/B,CAAd;;AACA,gBAAG;AACCD,cAAAA,OAAO,GAAG,KAAKI,YAAL,CAAkB,KAAKC,iBAAvB,EAA0C,KAAKC,iBAA/C,EAAkE3B,OAAlE,EAA2ET,OAA3E,EAAoF,GAApF,CAAV;;AACA,kBAAG8B,OAAO,IAAI,IAAd,EAAmB;AACf;AACH;;AACDjC,cAAAA,KAAK,CAACjB,IAAN,CAAWkD,OAAX;AACH,aAND,CAOA,OAAMxB,CAAN,EAAQ;AACJC,cAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACH;;AACD;;AACJ,eAAK,GAAL;AAEI;;AACJ,eAAK,GAAL;AAEI;;AACJ,eAAK,GAAL;AAEI;;AACJ;AACI;AA3BR;AA6BH;;AACD,aAAOX,KAAP;AACH;;;kCAEawC,G,EAAI;AACd,UAAIC,cAAc,GAAG,CAAC,GAAD,EAAK,GAAL,EAAS,GAAT,EAAa,GAAb,CAArB;AACA,UAAIC,UAAU,GAAG,EAAjB;AACA,UAAIxB,OAAO,GAAGsB,GAAd;;AACA,aAAMtB,OAAO,GAAG,CAAC,CAAjB,EAAmB;AACf,YAAIyB,GAAG,GAAGvB,IAAI,CAACE,KAAL,CAAYF,IAAI,CAACwB,MAAL,KAAiBH,cAAc,CAAClD,MAAjC,GAA4C,CAAvD,CAAV;AACAmD,QAAAA,UAAU,CAAC3D,IAAX,CAAgB0D,cAAc,CAACE,GAAD,CAA9B;AACAF,QAAAA,cAAc,CAACI,MAAf,CAAsBF,GAAtB,EAA2B,CAA3B;AACAzB,QAAAA,OAAO,IAAI,CAAX;AACH;;AACD,aAAOwB,UAAP;AACH;;;+BAEUI,G,EAAKC,G,EAAI;AAChB,UAAIxD,MAAM,GAAG6B,IAAI,CAACE,KAAL,CAAYF,IAAI,CAACwB,MAAL,KAAgBG,GAAjB,GAAwBD,GAAnC,CAAb;AACA,UAAI1E,KAAK,GAAGgD,IAAI,CAACE,KAAL,CAAYF,IAAI,CAACwB,MAAL,KAAgBG,GAAjB,GAAwBD,GAAnC,CAAZ;AACA,UAAMlE,GAAG,GAAG,CAACW,MAAD,EAASnB,KAAT,CAAZ;AACA,aAAOQ,GAAP;AACH;;;8BAESmD,I,EAAK;AACX;AACA,UAAIiB,SAAS,GAAGjB,IAAI,CAAC3D,KAArB;AACA,UAAI6E,SAAS,GAAGlB,IAAI,CAAC1D,MAArB;;AACA,WAAI,IAAIM,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGqE,SAAnB,EAA8BrE,CAAC,EAA/B,EAAkC;AAC9B,aAAI,IAAIE,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGoE,SAAnB,EAA8BpE,CAAC,EAA/B,EAAkC;AAC9B,cAAIqE,GAAG,GAAGnB,IAAI,CAACoB,QAAL,CAAcxE,CAAd,EAAiBE,CAAjB,EAAoBS,QAApB,CAA6B,CAA7B,CAAV;AACA,cAAI8D,GAAG,GAAGrB,IAAI,CAACoB,QAAL,CAAcxE,CAAd,EAAiBE,CAAjB,EAAoBS,QAApB,CAA6B,CAA7B,CAAV;;AACA,cAAG,KAAKd,KAAL,CAAW0E,GAAX,EAAgBE,GAAhB,EAAqB7B,IAArB,KAA8B,GAAjC,EACA;AACI,iBAAK/C,KAAL,CAAW0E,GAAX,EAAgBE,GAAhB,IAAuBrB,IAAI,CAACoB,QAAL,CAAcxE,CAAd,EAAiBE,CAAjB,CAAvB;AACA,iBAAKL,KAAL,CAAW0E,GAAX,EAAgBE,GAAhB,EAAqB5C,MAArB,GAA8B,IAA9B;AACH,WAJD,MAKI;AACA,iBAAKhC,KAAL,CAAW0E,GAAX,EAAgBE,GAAhB,EAAqB5C,MAArB,GAA8B,IAA9B;AACH;AACJ;AACJ;AACJ;;;wBAEa;AACV,aAAO,KAAKhC,KAAZ;AACH;;;;;;AAKL,eAAeP,GAAf","sourcesContent":["import {Room, Node} from './room'\r\n\r\nclass Map{\r\n    constructor(boardWidth, boardlength){\r\n        //describes the boards with relative to amount of squares\r\n        this.width = boardWidth;\r\n        this.height = boardlength;\r\n        this.clearedBoard = [];\r\n        //initialize the board with a clear state\r\n        this.clear()\r\n        this.board = this.clearedBoard\r\n        this.roomCounter = 8\r\n        this.createRooms(this.roomCounter)\r\n    }\r\n\r\n    clear(){\r\n        for(var i = 0; i < this.height; i++){\r\n            let arr = []\r\n            for(var j = 0; j < this.width; j++){\r\n                var emptyNodes = new Node('-', [i,j])\r\n                arr.push(emptyNodes)\r\n            }\r\n            this.clearedBoard.push(arr)\r\n        }\r\n    }\r\n    \r\n    createRooms(roomNumber){\r\n\r\n        var roomCount = roomNumber\r\n        var randomSize = [5,7]\r\n        var roomNode = new Room(randomSize[0], randomSize[1])\r\n        // //create some halls\r\n        var halls = this.generateHalls(2)\r\n        //initialize queue\r\n        var position = [25,40]\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            roomNode.buildCooridor(halls[i])\r\n        }\r\n        roomNode.changePosition(position)\r\n        roomNode.visited = true\r\n\r\n        this.placeRoom(roomNode)\r\n\r\n        var queue = []\r\n        queue.push(roomNode)\r\n        var randomCount = 5\r\n        while(queue.length){\r\n            var node = queue.shift(0)\r\n            if(node)\r\n            {\r\n                var rooms = this.generateRooms(node)\r\n                for(var i = 0; i < rooms.length; i++){\r\n                    this.placeRoom(rooms[i])\r\n                    queue.push(rooms[i])\r\n                }\r\n            }\r\n            return\r\n        }\r\n\r\n\r\n    }\r\n//methods for the right\r\n    rightColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n\r\n        try{\r\n            if(board[rowIdx][r].filled == false){\r\n                return [l,r]\r\n            }\r\n            else{\r\n                return null\r\n            }\r\n        }\r\n        catch(e){\r\n            console.log('column position is null with',l,r)\r\n        }\r\n    }\r\n    //shared method for both left and right\r\n    rightRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1] + 1\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var t = rowSpan[0]\r\n        var b = rowSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalT = t\r\n        var originalB = b\r\n\r\n        var counter = 0\r\n\r\n        var span = Math.abs(t-b)\r\n        //reduce by more than a half because of offsets\r\n        t = t - Math.floor((span/3))\r\n        b = b - Math.floor(span/3)\r\n        //update the span\r\n        span = Math.abs(t - b)\r\n        board[24][45].filled = true\r\n        board[25][45].filled = true\r\n        board[26][45].filled = true\r\n        try{\r\n            //if nothing has to be done return the positions as is\r\n            if(board[t][colIdx].filled == false && board[b][colIdx].filled == false){\r\n                console.log('returning original')\r\n                return [t,b]\r\n            }\r\n            else{\r\n                while(((board[t][colIdx].filled == true || board[b][colIdx].filled == true) ||\r\n                      (board[t][colIdx-1].type !== 'H' || board[b][colIdx-1].type !== 'H')) && \r\n                      counter < 3){\r\n                    console.log('reducing')\r\n                    //top is occupied, reduce by a quarter, usually just 1 because rooms are small right now\r\n                    if(board[t][colIdx].filled == true){\r\n                        t = t + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied, reduce by a quarter, usually just 1 because rooms are small right now\r\n                    if(board[b][colIdx].filled == true){\r\n                        b = b - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[t][colIdx].filled == false && board[b][colIdx].filled == false && \r\n                       (originalT >= t && originalB<= b)){\r\n                        console.log(originalT, t)\r\n                        return [t,b]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(t-b)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n\r\n    //goes to generateRoom for generateRooms()\r\n    generateRoom(rowcallback, colcallback, rowSpan, colSpan, direction){\r\n        var board = this.board\r\n        const rowPosition = rowcallback(rowSpan, colSpan[0], board)\r\n        const colPosition = colcallback(colSpan, rowSpan[0], board)\r\n        if(rowPosition == null || colPosition == null){\r\n            console.log('The positions are ', rowPosition, colPosition)\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n        const position = [rowPosition[0], colPosition[0]]\r\n\r\n        const room = new Room(rowSize, colSize)\r\n        const halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == direction ){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n        }\r\n\r\n        room.changePosition(position)\r\n        return room\r\n\r\n    }\r\n\r\n\r\n\r\n//where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\r\n    generateRooms(node){\r\n        const halls = node.halls\r\n        const len = halls.length\r\n        var rooms = []\r\n        let newRoom = null\r\n        for(var i = 0; i < len; i++){\r\n            let roomSize = this.randomSize(5,7)\r\n            let rowStart = halls[i].position[0]\r\n            let colStart =  halls[i].position[1]\r\n            switch(halls[i].direction){\r\n                case 'r':\r\n                    //the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart - 1, rowStart + roomSize[0] - 1]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart , colStart + roomSize[1]]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.rightRowPositions, this.rightColPositions, rowSpan, colSpan, 'l')\r\n                        if(newRoom == null){\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                case 'l':\r\n\r\n                    break\r\n                case 't':\r\n\r\n                    break\r\n                case 'b':\r\n\r\n                    break\r\n                default:\r\n                    break\r\n            }\r\n        }\r\n        return rooms\r\n    }\r\n\r\n    generateHalls(num){\r\n        var hallDirections = ['l','r','t','b']\r\n        var randomDirs = []\r\n        var counter = num\r\n        while(counter > -1){\r\n            var idx = Math.floor((Math.random() * (hallDirections.length)) + 0)\r\n            randomDirs.push(hallDirections[idx])\r\n            hallDirections.splice(idx, 1)\r\n            counter -= 1\r\n        }\r\n        return randomDirs\r\n    }\r\n\r\n    randomSize(min, max){\r\n        var length = Math.floor((Math.random() * max) + min);\r\n        var width = Math.floor((Math.random() * max) + min);\r\n        const arr = [length, width]\r\n        return arr\r\n    }\r\n    \r\n    placeRoom(room){\r\n        //where position is based on row, col for map\r\n        var rowLength = room.width\r\n        var colLength = room.height\r\n        for(var i = 0; i < rowLength; i++){\r\n            for(var j = 0; j < colLength; j++){\r\n                var row = room.contents[i][j].position[0]\r\n                var col = room.contents[i][j].position[1]\r\n                if(this.board[row][col].type !== 'H')\r\n                {\r\n                    this.board[row][col] = room.contents[i][j]\r\n                    this.board[row][col].filled = true\r\n                }\r\n                else{\r\n                    this.board[row][col].filled = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    get contents(){\r\n        return this.board;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Map"]},"metadata":{},"sourceType":"module"}
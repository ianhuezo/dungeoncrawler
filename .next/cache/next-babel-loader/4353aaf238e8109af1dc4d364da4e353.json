{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/esm/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/esm/createClass\"));\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  //how the room itself views the node\n  //will eventually put how the level itself views the\n  function Node(roomWalls, position) {\n    (0, _classCallCheck2[\"default\"])(this, Node);\n    this.type = null;\n    this.roomView = roomWalls; //position is [row, col] based\n\n    this.position = position;\n    this.filled = false; //only used for a subset of the nodes, the hallways\n\n    this.direction = ''; //empty tile\n\n    if (this.roomView == '-') {\n      this.type = '-';\n    } //means its a hallway/cooridor\n    else if (this.roomView == 'H') {\n        this.type = 'H';\n      } else if (this.roomView.corner) {\n        //corner\n        this.type = 'C';\n      } //sides of the room\n      else if (this.roomView.left || this.roomView.right || this.roomView.bottom || this.roomView.top) {\n          //\n          this.type = 'X';\n        } //the middle of the room\n        else {\n            this.type = 'L';\n          }\n\n    this.left = false;\n    this.right = false;\n    this.top = false;\n    this.bottom = false;\n    this.determineBarriers();\n  }\n\n  (0, _createClass2[\"default\"])(Node, [{\n    key: \"determineBarriers\",\n    value: function determineBarriers() {\n      switch (this.type) {\n        case 'O':\n          this.fillAll();\n          break;\n\n        case 'X':\n          this.fillAll();\n\n        case 'C':\n          this.fillAll();\n\n        default:\n          this.fillNone();\n      }\n    }\n  }, {\n    key: \"fillAll\",\n    value: function fillAll() {\n      this.left = true;\n      this.right = true;\n      this.bottom = true;\n      this.top = true;\n      this.filled = true;\n    }\n  }, {\n    key: \"fillNone\",\n    value: function fillNone() {\n      this.left = false;\n      this.right = false;\n      this.bottom = false;\n      this.top = false;\n      this.filled = false;\n    } //the room itself will create a cooridor from the nodes\n\n  }, {\n    key: \"createCooridor\",\n    value: function createCooridor(direction) {\n      //input is char for the direction \n      switch (direction) {\n        case 'l':\n          this.left = false;\n          this.right = true;\n          this.bottom = true;\n          this.top = true;\n          this.filled = false;\n\n        case 'r':\n          this.left = true;\n          this.right = false;\n          this.bottom = true;\n          this.top = true;\n          this.filled = false;\n\n        case 't':\n          this.left = true;\n          this.right = true;\n          this.bottom = true;\n          this.top = false;\n          this.filled = false;\n\n        case 'b':\n          this.left = true;\n          this.right = true;\n          this.bottom = false;\n          this.top = true;\n          this.filled = false;\n\n        default:\n          break;\n      }\n    }\n  }]);\n  return Node;\n}();\n\nvar Room =\n/*#__PURE__*/\nfunction () {\n  //default values for length and height\n  function Room() {\n    var height = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    var parentHall = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    (0, _classCallCheck2[\"default\"])(this, Room);\n    //startingPoint is the [row, col]\n    this.height = height;\n    this.width = width; //the cooridor will decide starting position if there is a parent node with a cooridor being input\n    //will overwrite the parents left, right, bottom, or top x and c's depending \n\n    this.parentHall = parentHall;\n\n    if (this.parentCooridor != null) {} //a list of all the nodes that can put a cooridor\n\n\n    this.viableSides = {\n      left: [],\n      right: [],\n      top: [],\n      bottom: []\n    };\n    this.visited = false; //construct the room with halls\n\n    this.halls = [];\n    this.roomContents = this.constructRoom();\n  }\n\n  (0, _createClass2[\"default\"])(Room, [{\n    key: \"constructRoom\",\n    value: function constructRoom() {\n      var roomArea = [];\n      this.constructFirstRoom(roomArea);\n      return roomArea;\n    }\n  }, {\n    key: \"constructFirstRoom\",\n    value: function constructFirstRoom(area) {\n      for (var i = 0; i < this.width; i++) //row\n      {\n        var roomRow = [];\n\n        for (var j = 0; j < this.height; j++) //col\n        {\n          //get all the logic for the walls\n          var wallBooleans = this.isWall(i, j); //assign viable indices to reference later when buildling cooridors\n\n          this.buildViableCooridors(wallBooleans, [i, j]); //create roomnodes that are \n\n          var roomNode = new Node(wallBooleans, [i, j]);\n          roomRow.push(roomNode);\n        }\n\n        area.push(roomRow);\n      }\n    } //record indices that can place a cooridor in the room\n\n  }, {\n    key: \"buildViableCooridors\",\n    value: function buildViableCooridors(wall, position) {\n      if (!wall.corner) {\n        if (wall.top && position[0] == 0) {\n          this.viableSides.top.push(position);\n        } else if (wall.bottom && position[0] == this.width - 1) {\n          this.viableSides.bottom.push(position);\n        } else if (wall.right && position[1] == this.height - 1) {\n          this.viableSides.right.push(position);\n        } else if (wall.left && position[1] == 0) {\n          this.viableSides.left.push(position);\n        }\n      }\n    }\n  }, {\n    key: \"isWall\",\n    value: function isWall(row, col) {\n      //all directions walls are in\n      // const isLeft = (col == 0 && row < this.width)\n      // const isRight = (col == this.height - 1 && row < this.width)\n      // const isTop = (col < this.height - 1 && row == 0)\n      // const isBottom = (row == this.height)\n      var isTop = row == 0;\n      var isBottom = row == this.width - 1;\n      var isLeft = col == 0;\n      var isRight = col == this.height - 1; //corner cases\n\n      var isTopLeft = isLeft && isTop;\n      var isTopRight = isRight && isTop;\n      var isBottomLeft = isLeft && isBottom;\n      var isBottomRight = isRight && isBottom;\n      var isCorner = isTopLeft || isTopRight || isBottomLeft || isBottomRight;\n      return {\n        right: isRight,\n        left: isLeft,\n        top: isTop,\n        bottom: isBottom,\n        topLeft: isTopLeft,\n        topRight: isTopRight,\n        bottomLeft: isBottomLeft,\n        bottomRight: isBottomRight,\n        corner: isCorner,\n        cooridor: false\n      };\n    }\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(position) {\n      for (var i = 0; i < this.width; i++) {\n        for (var j = 0; j < this.height; j++) {\n          this.roomContents[i][j].position = [this.roomContents[i][j].position[0] + position[0], this.roomContents[i][j].position[1] + position[1]];\n        }\n      }\n    }\n  }, {\n    key: \"updateSide\",\n    value: function updateSide(key, position) {\n      var newArr = [];\n\n      for (var ele in this.viableSides[key]) {\n        newArr.push([ele[0] + position[0], ele[1] + position[1]]);\n      }\n\n      this.viableSides[key] = newArr;\n    }\n  }, {\n    key: \"updateViableSides\",\n    value: function updateViableSides(position) {\n      this.updateSide(\"left\", position);\n      this.updateSide(\"righ\", position);\n      this.updateSide(\"top\", position);\n      this.updateSide(\"bottom\", position);\n    }\n  }, {\n    key: \"changePosition\",\n    value: function changePosition(position) {\n      //where position is the position of the whole map wanted, will be from top left starting\n      //update regular room nodes\n      this.updatePosition(position); //update halls to new position\n      // this.updateViableSides(position)\n    }\n  }, {\n    key: \"removeCooridor\",\n    value: function removeCooridor(direction) {\n      if (this.halls) {\n        for (var i = 0; i < this.halls.length; i++) {\n          if (this.halls[i].direction == direction) {\n            //replace the node with a blank node\n            console.log(this.halls[i]);\n            var val = this.halls.pop(i);\n            return val;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"buildCooridor\",\n    value: function buildCooridor(direction) {\n      //direction is the input from map that will \n      //determine where to put something\n      //builds a cooridor where the x was\n      //choose from random position\n      var randomPosition = null;\n\n      switch (direction) {\n        case 'l':\n          randomPosition = this.viableSides.left.random();\n          break;\n\n        case 'r':\n          randomPosition = this.viableSides.right.random();\n          break;\n\n        case 't':\n          randomPosition = this.viableSides.top.random();\n          break;\n\n        case 'b':\n          randomPosition = this.viableSides.bottom.random();\n          break;\n\n        default:\n          break;\n      }\n\n      if (randomPosition == null) {\n        return;\n      }\n\n      var row = randomPosition[0];\n      var col = randomPosition[1]; //take the roomView attribute of the node\n      //create the node and reference which direction it is to the room\n\n      var cooridorNode = new Node('H', [row, col]);\n      cooridorNode.createCooridor(direction);\n      cooridorNode.direction = direction;\n      this.halls.push(cooridorNode); //assign back to the room\n\n      this.roomContents[row][col] = cooridorNode;\n    } //rooms could be different size, so go off the smaller room for merging\n\n  }, {\n    key: \"contents\",\n    get: function get() {\n      return this.roomContents;\n    }\n  }]);\n  return Room;\n}(); //from https://stackoverflow.com/questions/5915096/get-random-item-from-javascript-array, because looked simple and elegant\n\n\nArray.prototype.random = function () {\n  return this[Math.floor(Math.random() * this.length)];\n};\n\nmodule.exports = {\n  Room: Room,\n  Node: Node\n};","map":{"version":3,"sources":["D:\\Programming\\Dungeon Crawler\\pages\\room.js"],"names":["Node","roomWalls","position","type","roomView","filled","direction","corner","left","right","bottom","top","determineBarriers","fillAll","fillNone","Room","height","width","parentHall","parentCooridor","viableSides","visited","halls","roomContents","constructRoom","roomArea","constructFirstRoom","area","i","roomRow","j","wallBooleans","isWall","buildViableCooridors","roomNode","push","wall","row","col","isTop","isBottom","isLeft","isRight","isTopLeft","isTopRight","isBottomLeft","isBottomRight","isCorner","topLeft","topRight","bottomLeft","bottomRight","cooridor","key","newArr","ele","updateSide","updatePosition","length","console","log","val","pop","randomPosition","random","cooridorNode","createCooridor","Array","prototype","Math","floor","module","exports"],"mappings":"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","sourcesContent":["class Node{\r\n    //how the room itself views the node\r\n    //will eventually put how the level itself views the\r\n    constructor(roomWalls, position){\r\n        this.type = null;\r\n        this.roomView = roomWalls\r\n        //position is [row, col] based\r\n        this.position = position\r\n        this.filled = false\r\n        //only used for a subset of the nodes, the hallways\r\n        this.direction = ''\r\n        \r\n        //empty tile\r\n        if(this.roomView == '-'){\r\n            this.type = '-'\r\n        }\r\n        //means its a hallway/cooridor\r\n        else if(this.roomView == 'H'){\r\n            this.type = 'H';\r\n        }\r\n        else if(this.roomView.corner){\r\n            //corner\r\n            this.type = 'C';\r\n        }\r\n        //sides of the room\r\n        else if(this.roomView.left || this.roomView.right || this.roomView.bottom || this.roomView.top){\r\n            //\r\n            this.type = 'X';\r\n        }\r\n        //the middle of the room\r\n        else{\r\n            this.type = 'L';\r\n        }\r\n        this.left = false;\r\n        this.right = false;\r\n        this.top = false;\r\n        this.bottom = false;\r\n\r\n        this.determineBarriers();\r\n\r\n    }\r\n    determineBarriers(){\r\n        switch (this.type){\r\n            case 'O':\r\n                this.fillAll()\r\n                break\r\n            case 'X':\r\n                this.fillAll()\r\n            case 'C':\r\n                this.fillAll()\r\n            default:\r\n                this.fillNone()\r\n        }\r\n    }\r\n\r\n    fillAll(){\r\n        this.left = true\r\n        this.right = true\r\n        this.bottom = true\r\n        this.top = true\r\n        this.filled = true\r\n    }\r\n\r\n    fillNone(){\r\n        this.left = false\r\n        this.right = false\r\n        this.bottom = false\r\n        this.top = false\r\n        this.filled = false\r\n    }\r\n    //the room itself will create a cooridor from the nodes\r\n    createCooridor(direction){\r\n        //input is char for the direction \r\n        switch(direction){\r\n            case 'l':\r\n                this.left = false\r\n                this.right = true\r\n                this.bottom = true\r\n                this.top = true\r\n                this.filled = false\r\n            case 'r':\r\n                this.left = true\r\n                this.right = false\r\n                this.bottom = true\r\n                this.top = true\r\n                this.filled = false\r\n            case 't':\r\n                this.left = true\r\n                this.right = true\r\n                this.bottom = true\r\n                this.top = false\r\n                this.filled = false\r\n            case 'b':\r\n                this.left = true\r\n                this.right = true\r\n                this.bottom = false\r\n                this.top = true\r\n                this.filled = false\r\n            default:\r\n                break\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nclass Room{\r\n    //default values for length and height\r\n    constructor(height = 10, width = 10,parentHall = null){\r\n        //startingPoint is the [row, col]\r\n        this.height = height;\r\n        this.width = width;\r\n\r\n        //the cooridor will decide starting position if there is a parent node with a cooridor being input\r\n        //will overwrite the parents left, right, bottom, or top x and c's depending \r\n        this.parentHall = parentHall;\r\n        if(this.parentCooridor != null){\r\n\r\n        }\r\n        //a list of all the nodes that can put a cooridor\r\n        this.viableSides = {\r\n            left : [],\r\n            right: [],\r\n            top: [],\r\n            bottom: []\r\n        }\r\n        this.visited = false\r\n        //construct the room with halls\r\n        this.halls = []\r\n        this.roomContents = this.constructRoom();\r\n    }\r\n    constructRoom(){\r\n       \r\n        let roomArea = [];\r\n        this.constructFirstRoom(roomArea)\r\n        return roomArea;\r\n    }\r\n\r\n    get contents(){\r\n        return this.roomContents;\r\n    }\r\n\r\n\r\n    constructFirstRoom(area){\r\n        for (var i = 0; i < this.width; i++)//row\r\n        {\r\n            let roomRow = [];\r\n            for(var j = 0; j < this.height; j++)//col\r\n            {\r\n                //get all the logic for the walls\r\n                let wallBooleans = this.isWall(i, j);\r\n                //assign viable indices to reference later when buildling cooridors\r\n                this.buildViableCooridors(wallBooleans, [i,j])\r\n                //create roomnodes that are \r\n                let roomNode = new Node(wallBooleans, [i,j])\r\n                roomRow.push(roomNode);\r\n            }\r\n            area.push(roomRow);\r\n        }\r\n    }\r\n    //record indices that can place a cooridor in the room\r\n    buildViableCooridors(wall, position){\r\n        if(!wall.corner){\r\n            if(wall.top && position[0] == 0){\r\n                this.viableSides.top.push(position)\r\n            }\r\n            else if(wall.bottom && position[0] == this.width - 1){\r\n                this.viableSides.bottom.push(position)\r\n            }\r\n            else if(wall.right && position[1] == this.height - 1){\r\n                this.viableSides.right.push(position)\r\n            }\r\n            else if(wall.left && position[1] == 0){\r\n                this.viableSides.left.push(position)\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    isWall(row, col){\r\n        //all directions walls are in\r\n        // const isLeft = (col == 0 && row < this.width)\r\n        // const isRight = (col == this.height - 1 && row < this.width)\r\n        // const isTop = (col < this.height - 1 && row == 0)\r\n        // const isBottom = (row == this.height)\r\n        const isTop = (row == 0)\r\n        const isBottom = (row == this.width - 1)\r\n        const isLeft = (col == 0)\r\n        const isRight = (col == this.height - 1)\r\n        //corner cases\r\n        const isTopLeft = isLeft && isTop;\r\n        const isTopRight = isRight && isTop;\r\n        const isBottomLeft = isLeft && isBottom;\r\n        const isBottomRight = isRight && isBottom;\r\n        const isCorner = (isTopLeft || isTopRight || isBottomLeft || isBottomRight);\r\n        return {\r\n            right: isRight,\r\n            left: isLeft,\r\n            top: isTop,\r\n            bottom: isBottom,\r\n            topLeft: isTopLeft,\r\n            topRight: isTopRight,\r\n            bottomLeft: isBottomLeft,\r\n            bottomRight: isBottomRight,\r\n            corner: isCorner,\r\n            cooridor: false\r\n        }\r\n    }\r\n\r\n    updatePosition(position){\r\n        for(var i = 0; i < this.width; i++){\r\n            for(var j = 0; j < this.height; j++){\r\n                this.roomContents[i][j].position = [this.roomContents[i][j].position[0] + position[0],this.roomContents[i][j].position[1] + position[1]]\r\n            }\r\n        }\r\n    }\r\n\r\n    updateSide(key, position){\r\n        var newArr = []\r\n        for(var ele in this.viableSides[key]){\r\n            newArr.push([ele[0] + position[0], ele[1] + position[1]])\r\n        }\r\n        this.viableSides[key] = newArr\r\n    }\r\n\r\n    updateViableSides(position){\r\n        this.updateSide(\"left\", position)\r\n        this.updateSide(\"righ\", position)\r\n        this.updateSide(\"top\", position)\r\n        this.updateSide(\"bottom\", position)\r\n    }\r\n\r\n    changePosition(position){\r\n        //where position is the position of the whole map wanted, will be from top left starting\r\n\r\n        //update regular room nodes\r\n        this.updatePosition(position)\r\n        //update halls to new position\r\n        // this.updateViableSides(position)\r\n    }\r\n\r\n    removeCooridor(direction){\r\n        if(this.halls){\r\n            for(var i = 0; i < this.halls.length; i++){\r\n                if(this.halls[i].direction == direction){\r\n                    //replace the node with a blank node\r\n                    console.log(this.halls[i])\r\n                    var val = this.halls.pop(i)\r\n                    return val\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    buildCooridor(direction){\r\n        //direction is the input from map that will \r\n        //determine where to put something\r\n        //builds a cooridor where the x was\r\n        //choose from random position\r\n        var randomPosition = null\r\n        switch(direction){\r\n            case 'l':\r\n                randomPosition = this.viableSides.left.random()\r\n                break;\r\n            case 'r':\r\n                randomPosition = this.viableSides.right.random()\r\n                break;\r\n            case 't':\r\n                randomPosition = this.viableSides.top.random()\r\n                break;\r\n            case 'b':\r\n                randomPosition = this.viableSides.bottom.random()\r\n                break;\r\n            default:\r\n                break\r\n        }\r\n        if(randomPosition == null){\r\n            return\r\n        }\r\n        const row = randomPosition[0]\r\n        const col = randomPosition[1]\r\n        //take the roomView attribute of the node\r\n\r\n        //create the node and reference which direction it is to the room\r\n        var cooridorNode = new Node('H', [row,col])\r\n        cooridorNode.createCooridor(direction)\r\n        cooridorNode.direction = direction\r\n        this.halls.push(cooridorNode)\r\n        //assign back to the room\r\n        this.roomContents[row][col] = cooridorNode\r\n    }\r\n    //rooms could be different size, so go off the smaller room for merging\r\n\r\n}\r\n//from https://stackoverflow.com/questions/5915096/get-random-item-from-javascript-array, because looked simple and elegant\r\nArray.prototype.random = function () {\r\n    return this[Math.floor((Math.random()*this.length))];\r\n  }\r\n\r\n  module.exports = {\r\n      Room,\r\n      Node\r\n  }"]},"metadata":{},"sourceType":"script"}
{"version":3,"file":"static/webpack/static\\development\\pages\\index.js.cc90b32e6978cabdc5a5.hot-update.js","sources":["webpack:///./pages/map.js"],"sourcesContent":["import {Room, Node} from './room'\r\n\r\nclass Map{\r\n    constructor(boardWidth, boardlength){\r\n        //describes the boards with relative to amount of squares\r\n        this.width = boardWidth;\r\n        this.height = boardlength;\r\n        this.clearedBoard = [];\r\n        //initialize the board with a clear state\r\n        this.clear()\r\n        this.board = this.clearedBoard\r\n        this.roomCounter = 8\r\n        this.createRooms(this.roomCounter)\r\n    }\r\n\r\n    clear(){\r\n        for(var i = 0; i < this.height; i++){\r\n            let arr = []\r\n            for(var j = 0; j < this.width; j++){\r\n                var emptyNodes = new Node('-', [i,j])\r\n                arr.push(emptyNodes)\r\n            }\r\n            this.clearedBoard.push(arr)\r\n        }\r\n    }\r\n    \r\n    createRooms(roomNumber){\r\n\r\n        var roomCount = roomNumber\r\n        var randomSize = [5,7]\r\n        var roomNode = new Room(randomSize[0], randomSize[1])\r\n        // //create some halls\r\n        var halls = this.generateHalls(2)\r\n        //initialize queue\r\n        var position = [25,40]\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            roomNode.buildCooridor(halls[i])\r\n        }\r\n        roomNode.changePosition(position)\r\n        roomNode.visited = true\r\n\r\n        this.placeRoom(roomNode)\r\n\r\n        var queue = []\r\n        queue.push(roomNode)\r\n        var randomCount = 5\r\n        while(queue.length){\r\n            var node = queue.shift(0)\r\n            if(node)\r\n            {\r\n                var rooms = this.generateRooms(node)\r\n                for(var i = 0; i < rooms.length; i++){\r\n                    this.placeRoom(rooms[i])\r\n                    queue.push(rooms[i])\r\n                }\r\n            }\r\n            return\r\n        }\r\n\r\n\r\n    }\r\n//methods for the right\r\n    rightColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n\r\n        try{\r\n            if(board[rowIdx][r].filled == false){\r\n                return [l,r]\r\n            }\r\n            else{\r\n                return null\r\n            }\r\n        }\r\n        catch(e){\r\n            console.log('column position is null with',l,r)\r\n        }\r\n    }\r\n    //shared method for both left and right\r\n    rightRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1] + 1\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var t = rowSpan[0]\r\n        var b = rowSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalT = t\r\n        var originalB = b\r\n\r\n        var counter = 0\r\n\r\n        var span = Math.abs(t-b)\r\n        //reduce by more than a half because of offsets\r\n        t = t - Math.floor((span/3))\r\n        b = b - Math.floor(span/3)\r\n        //update the span\r\n        span = Math.abs(t - b)\r\n        board[24][45].filled = true\r\n        board[25][45].filled = true\r\n        board[26][45].filled = true\r\n        try{\r\n            //if nothing has to be done return the positions as is\r\n            if(board[t][colIdx].filled == false && board[b][colIdx].filled == false){\r\n                console.log('returning original')\r\n                return [t,b]\r\n            }\r\n            else{\r\n                while(((board[t][colIdx].filled == true || board[b][colIdx].filled == true) ||\r\n                      (board[t][colIdx-1].type !== 'H' || board[b][colIdx-1].type !== 'H')) && \r\n                      counter < 3){\r\n                    console.log('reducing')\r\n                    //top is occupied, reduce by a quarter, usually just 1 because rooms are small right now\r\n                    if(board[t][colIdx].filled == true){\r\n                        t = t + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied, reduce by a quarter, usually just 1 because rooms are small right now\r\n                    if(board[b][colIdx].filled == true){\r\n                        b = b - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[t][colIdx].filled == false && board[b][colIdx].filled == false && \r\n                       (originalT >= t &&  b > originalT)){\r\n                        console.log(originalB, B)\r\n                        return [t,b]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(t-b)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n\r\n    //goes to generateRoom for generateRooms()\r\n    generateRoom(rowcallback, colcallback, rowSpan, colSpan, direction){\r\n        var board = this.board\r\n        const rowPosition = rowcallback(rowSpan, colSpan[0], board)\r\n        const colPosition = colcallback(colSpan, rowSpan[0], board)\r\n        if(rowPosition == null || colPosition == null){\r\n            console.log('The positions are ', rowPosition, colPosition)\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n        const position = [rowPosition[0], colPosition[0]]\r\n\r\n        const room = new Room(rowSize, colSize)\r\n        const halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == direction ){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n        }\r\n\r\n        room.changePosition(position)\r\n        return room\r\n\r\n    }\r\n\r\n\r\n\r\n//where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\r\n    generateRooms(node){\r\n        const halls = node.halls\r\n        const len = halls.length\r\n        var rooms = []\r\n        let newRoom = null\r\n        for(var i = 0; i < len; i++){\r\n            let roomSize = this.randomSize(5,7)\r\n            let rowStart = halls[i].position[0]\r\n            let colStart =  halls[i].position[1]\r\n            switch(halls[i].direction){\r\n                case 'r':\r\n                    //the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart - 1, rowStart + roomSize[0] - 1]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart , colStart + roomSize[1]]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.rightRowPositions, this.rightColPositions, rowSpan, colSpan, 'l')\r\n                        if(newRoom == null){\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                case 'l':\r\n\r\n                    break\r\n                case 't':\r\n\r\n                    break\r\n                case 'b':\r\n\r\n                    break\r\n                default:\r\n                    break\r\n            }\r\n        }\r\n        return rooms\r\n    }\r\n\r\n    generateHalls(num){\r\n        var hallDirections = ['l','r','t','b']\r\n        var randomDirs = []\r\n        var counter = num\r\n        while(counter > -1){\r\n            var idx = Math.floor((Math.random() * (hallDirections.length)) + 0)\r\n            randomDirs.push(hallDirections[idx])\r\n            hallDirections.splice(idx, 1)\r\n            counter -= 1\r\n        }\r\n        return randomDirs\r\n    }\r\n\r\n    randomSize(min, max){\r\n        var length = Math.floor((Math.random() * max) + min);\r\n        var width = Math.floor((Math.random() * max) + min);\r\n        const arr = [length, width]\r\n        return arr\r\n    }\r\n    \r\n    placeRoom(room){\r\n        //where position is based on row, col for map\r\n        var rowLength = room.width\r\n        var colLength = room.height\r\n        for(var i = 0; i < rowLength; i++){\r\n            for(var j = 0; j < colLength; j++){\r\n                var row = room.contents[i][j].position[0]\r\n                var col = room.contents[i][j].position[1]\r\n                if(this.board[row][col].type !== 'H')\r\n                {\r\n                    this.board[row][col] = room.contents[i][j]\r\n                    this.board[row][col].filled = true\r\n                }\r\n                else{\r\n                    this.board[row][col].filled = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    get contents(){\r\n        return this.board;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Map"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AA3BA;AA6BA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;;;;AAKA;;;;A","sourceRoot":""}
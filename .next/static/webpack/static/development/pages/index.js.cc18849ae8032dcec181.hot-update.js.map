{"version":3,"file":"static/webpack/static\\development\\pages\\index.js.cc18849ae8032dcec181.hot-update.js","sources":["webpack:///./pages/room.js"],"sourcesContent":["class Node{\r\n    //how the room itself views the node\r\n    //will eventually put how the level itself views the\r\n    constructor(roomWalls, position){\r\n        this.type = null;\r\n        this.roomView = roomWalls\r\n        //position is [row, col] based\r\n        this.position = position\r\n        this.filled = false\r\n        //only used for a subset of the nodes, the hallways\r\n        this.direction = ''\r\n        \r\n        //empty tile\r\n        if(this.roomView == '-'){\r\n            this.type = '-'\r\n        }\r\n        //means its a hallway/cooridor\r\n        else if(this.roomView == 'H'){\r\n            this.type = 'H';\r\n        }\r\n        else if(this.roomView.corner){\r\n            //corner\r\n            this.type = 'C';\r\n        }\r\n        //sides of the room\r\n        else if(this.roomView.left || this.roomView.right || this.roomView.bottom || this.roomView.top){\r\n            //\r\n            this.type = 'X';\r\n        }\r\n        //the middle of the room\r\n        else{\r\n            this.type = 'L';\r\n        }\r\n        this.left = false;\r\n        this.right = false;\r\n        this.top = false;\r\n        this.bottom = false;\r\n\r\n        this.determineBarriers();\r\n\r\n    }\r\n    determineBarriers(){\r\n        switch (this.type){\r\n            case 'O':\r\n                this.fillAll()\r\n                break\r\n            case 'X':\r\n                this.fillAll()\r\n            case 'C':\r\n                this.fillAll()\r\n            default:\r\n                this.fillNone()\r\n        }\r\n    }\r\n\r\n    fillAll(){\r\n        this.left = true\r\n        this.right = true\r\n        this.bottom = true\r\n        this.top = true\r\n        this.filled = true\r\n    }\r\n\r\n    fillNone(){\r\n        this.left = false\r\n        this.right = false\r\n        this.bottom = false\r\n        this.top = false\r\n        this.filled = false\r\n    }\r\n    //the room itself will create a cooridor from the nodes\r\n    createCooridor(direction){\r\n        //input is char for the direction \r\n        switch(direction){\r\n            case 'l':\r\n                this.left = false\r\n                this.right = true\r\n                this.bottom = true\r\n                this.top = true\r\n                this.filled = false\r\n            case 'r':\r\n                this.left = true\r\n                this.right = false\r\n                this.bottom = true\r\n                this.top = true\r\n                this.filled = false\r\n            case 't':\r\n                this.left = true\r\n                this.right = true\r\n                this.bottom = true\r\n                this.top = false\r\n                this.filled = false\r\n            case 'b':\r\n                this.left = true\r\n                this.right = true\r\n                this.bottom = false\r\n                this.top = true\r\n                this.filled = false\r\n            default:\r\n                break\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nclass Room{\r\n    //default values for length and height\r\n    constructor(height = 10, width = 10,parentHall = null){\r\n        //startingPoint is the [row, col]\r\n        this.height = height;\r\n        this.width = width;\r\n\r\n        //the cooridor will decide starting position if there is a parent node with a cooridor being input\r\n        //will overwrite the parents left, right, bottom, or top x and c's depending \r\n        this.parentHall = parentHall;\r\n        if(this.parentCooridor != null){\r\n\r\n        }\r\n        //a list of all the nodes that can put a cooridor\r\n        this.viableSides = {\r\n            left : [],\r\n            right: [],\r\n            top: [],\r\n            bottom: []\r\n        }\r\n        this.visited = false\r\n        //construct the room with halls\r\n        this.halls = []\r\n        this.roomContents = this.constructRoom();\r\n    }\r\n    constructRoom(){\r\n       \r\n        let roomArea = [];\r\n        this.constructFirstRoom(roomArea)\r\n        return roomArea;\r\n    }\r\n\r\n    get contents(){\r\n        return this.roomContents;\r\n    }\r\n\r\n\r\n    constructFirstRoom(area){\r\n        for (var i = 0; i < this.width; i++)//row\r\n        {\r\n            let roomRow = [];\r\n            for(var j = 0; j < this.height; j++)//col\r\n            {\r\n                //get all the logic for the walls\r\n                let wallBooleans = this.isWall(i, j);\r\n                //assign viable indices to reference later when buildling cooridors\r\n                this.buildViableCooridors(wallBooleans, [i,j])\r\n                //create roomnodes that are \r\n                let roomNode = new Node(wallBooleans, [i,j])\r\n                roomRow.push(roomNode);\r\n            }\r\n            area.push(roomRow);\r\n        }\r\n    }\r\n    //record indices that can place a cooridor in the room\r\n    buildViableCooridors(wall, position){\r\n        if(!wall.corner){\r\n            if(wall.top && position[0] == 0){\r\n                this.viableSides.top.push(position)\r\n            }\r\n            else if(wall.bottom && position[0] == this.width - 1){\r\n                this.viableSides.bottom.push(position)\r\n            }\r\n            else if(wall.right && position[1] == this.height - 1){\r\n                this.viableSides.right.push(position)\r\n            }\r\n            else if(wall.left && position[1] == 0){\r\n                this.viableSides.left.push(position)\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    isWall(row, col){\r\n        //all directions walls are in\r\n        // const isLeft = (col == 0 && row < this.width)\r\n        // const isRight = (col == this.height - 1 && row < this.width)\r\n        // const isTop = (col < this.height - 1 && row == 0)\r\n        // const isBottom = (row == this.height)\r\n        const isTop = (row == 0)\r\n        const isBottom = (row == this.width - 1)\r\n        const isLeft = (col == 0)\r\n        const isRight = (col == this.height - 1)\r\n        //corner cases\r\n        const isTopLeft = isLeft && isTop;\r\n        const isTopRight = isRight && isTop;\r\n        const isBottomLeft = isLeft && isBottom;\r\n        const isBottomRight = isRight && isBottom;\r\n        const isCorner = (isTopLeft || isTopRight || isBottomLeft || isBottomRight);\r\n        return {\r\n            right: isRight,\r\n            left: isLeft,\r\n            top: isTop,\r\n            bottom: isBottom,\r\n            topLeft: isTopLeft,\r\n            topRight: isTopRight,\r\n            bottomLeft: isBottomLeft,\r\n            bottomRight: isBottomRight,\r\n            corner: isCorner,\r\n            cooridor: false\r\n        }\r\n    }\r\n\r\n    updatePosition(position){\r\n        for(var i = 0; i < this.width; i++){\r\n            for(var j = 0; j < this.height; j++){\r\n                this.roomContents[i][j].position = [this.roomContents[i][j].position[0] + position[0],this.roomContents[i][j].position[1] + position[1]]\r\n            }\r\n        }\r\n    }\r\n\r\n    updateSide(key, position){\r\n        var newArr = []\r\n        for(var ele in this.viableSides[key]){\r\n            newArr.push([ele[0] + position[0], ele[1] + position[1]])\r\n        }\r\n        this.viableSides[key] = newArr\r\n    }\r\n\r\n    updateViableSides(position){\r\n        this.updateSide(\"left\", position)\r\n        this.updateSide(\"righ\", position)\r\n        this.updateSide(\"top\", position)\r\n        this.updateSide(\"bottom\", position)\r\n    }\r\n\r\n    changePosition(position){\r\n        //where position is the position of the whole map wanted, will be from top left starting\r\n\r\n        //update regular room nodes\r\n        this.updatePosition(position)\r\n        //update halls to new position\r\n        // this.updateViableSides(position)\r\n    }\r\n\r\n    removeCooridor(direction){\r\n        for(var i = 0; i < this.halls; i++){\r\n            if(this.halls[i].direction == direction){\r\n                //replace the node with a blank node\r\n                console.log(this.halls[i])\r\n                var val = this.halls.pop(i)\r\n                return val\r\n            }\r\n        }\r\n    }\r\n\r\n    buildCooridor(direction){\r\n        //direction is the input from map that will \r\n        //determine where to put something\r\n        //builds a cooridor where the x was\r\n        //choose from random position\r\n        var randomPosition = null\r\n        switch(direction){\r\n            case 'l':\r\n                randomPosition = this.viableSides.left.random()\r\n                break;\r\n            case 'r':\r\n                randomPosition = this.viableSides.right.random()\r\n                break;\r\n            case 't':\r\n                randomPosition = this.viableSides.top.random()\r\n                break;\r\n            case 'b':\r\n                randomPosition = this.viableSides.bottom.random()\r\n                break;\r\n            default:\r\n                break\r\n        }\r\n        if(randomPosition == null){\r\n            return\r\n        }\r\n        const row = randomPosition[0]\r\n        const col = randomPosition[1]\r\n        //take the roomView attribute of the node\r\n\r\n        //create the node and reference which direction it is to the room\r\n        var cooridorNode = new Node('H', [row,col])\r\n        cooridorNode.createCooridor(direction)\r\n        cooridorNode.direction = direction\r\n        this.halls.push(cooridorNode)\r\n        //assign back to the room\r\n        this.roomContents[row][col] = cooridorNode\r\n    }\r\n    //rooms could be different size, so go off the smaller room for merging\r\n\r\n}\r\n//from https://stackoverflow.com/questions/5915096/get-random-item-from-javascript-array, because looked simple and elegant\r\nArray.prototype.random = function () {\r\n    return this[Math.floor((Math.random()*this.length))];\r\n  }\r\n\r\n  module.exports = {\r\n      Room,\r\n      Node\r\n  }"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AATA;AAWA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AA1BA;AA4BA;;;;;AAKA;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AAEA;AACA;AACA;AACA;;;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AAEA;AACA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAdA;AACA;AAeA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAvJA;AACA;AACA;;;AAwJA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;;;;A","sourceRoot":""}
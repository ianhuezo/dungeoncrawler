{"version":3,"file":"static/webpack/static\\development\\pages\\index.js.004c09511449252067b5.hot-update.js","sources":["webpack:///./pages/map.js"],"sourcesContent":["import {Room, Node} from './room'\r\n\r\nclass Map{\r\n    constructor(boardWidth, boardlength){\r\n        //describes the boards with relative to amount of squares\r\n        this.width = boardWidth;\r\n        this.height = boardlength;\r\n        this.clearedBoard = [];\r\n        //initialize the board with a clear state\r\n        this.clear()\r\n        this.board = this.clearedBoard\r\n        this.roomCounter = 8\r\n        this.createRooms(this.roomCounter)\r\n    }\r\n\r\n    clear(){\r\n        for(var i = 0; i < this.height; i++){\r\n            let arr = []\r\n            for(var j = 0; j < this.width; j++){\r\n                var emptyNodes = new Node('-', [i,j])\r\n                arr.push(emptyNodes)\r\n            }\r\n            this.clearedBoard.push(arr)\r\n        }\r\n    }\r\n    \r\n    createRooms(roomNumber){\r\n\r\n        var roomCount = roomNumber\r\n        var randomSize = this.randomSize(5, 7)\r\n        var roomNode = new Room(randomSize[0], randomSize[1])\r\n        // //create some halls\r\n        var halls = this.generateHalls(2)\r\n        //initialize queue\r\n        var position = [25,40]\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            roomNode.buildCooridor(halls[i])\r\n        }\r\n        roomNode.changePosition(position)\r\n        roomNode.visited = true\r\n\r\n        this.placeRoom(roomNode)\r\n\r\n        var queue = []\r\n        queue.push(roomNode)\r\n        var randomCount = 5\r\n        while(queue.length){\r\n            var node = queue.shift(0)\r\n            if(node)\r\n            {\r\n                var rooms = this.generateRooms(node)\r\n                for(var i = 0; i < rooms.length; i++){\r\n                    this.placeRoom(rooms[i])\r\n                    queue.push(rooms[i])\r\n                }\r\n                randomCount -= 1\r\n            }\r\n            randomCount -= 1\r\n        }\r\n\r\n\r\n    }\r\n//methods for the right\r\n    searchRightColPosition(rowIdx, colSpan){\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n        var span = r - l\r\n        var counter = 0\r\n        //if the index is not filled then you're fine, return r\r\n        if(this.board[rowIdx][r].filled == false){\r\n            return [l,r]\r\n        }\r\n        //else if its a bad index binary search for a good one unless there isn't one\r\n        else{\r\n            while(this.board[rowIdx][r].filled == true && counter < 3){\r\n                var half = Math.floor((span/2) + l)\r\n                console.log('Right col is readjusting...')\r\n                if(this.board[rowIdx][half].filled == false){\r\n                    return [l,half]\r\n                }\r\n                else{\r\n                    span = half - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n    //shared method for both left and right\r\n    searchTopBottomRowPosition(rowSpan, colIdx){\r\n        //returns an array of the top and bottom indices for the rows\r\n        var t = rowSpan[0] + 1\r\n        var b = rowSpan[1] + 1\r\n        //the span of the rows\r\n        var span = Math.abs(t-b)\r\n        //offset by half\r\n        t = t - Math.floor(span/3)\r\n        if(t < 0){\r\n            t = 0\r\n        }\r\n        b = b - Math.floor(span/3)\r\n        var counter = 0\r\n\r\n        //search both top and bottom for a good offset\r\n        if(this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false){\r\n            return [t,b]\r\n        }\r\n        //quarters\r\n        else{\r\n            while(this.board[t][colIdx].filled == false && this.board[b][colIdx].filled == false && counter < 3){\r\n                console.log('Top Bottom is readjusting...')\r\n                var topQuartile = Math.floor((span/4) + t)\r\n                //because bottom is lower in count...\r\n                var bottomQuartile = Math.floor(b - (span/4))\r\n                if(this.board[topQuartile][colIdx].filled == true && this.board[bottomQuartile][colIdx].filled == true){\r\n                    return [topQuartile, bottomQuartile]\r\n                }\r\n                //could be more complex statements  depending on the dungeon I decide\r\n                else{\r\n                    t = Math.floor((span/4) + t) + 1\r\n                    b = Math.floor(b - (span/4)) - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    placeRight(pos,dir){\r\n        //need to account for the offset from the non filled room\r\n        pos = [pos[0] - 1, pos[1]]\r\n        var roomSize = this.randomSize(5,7)\r\n        var rowSpan = [pos[0], pos[0] + roomSize[0]]\r\n        var colSpan = [pos[1], pos[1] + roomSize[1]]\r\n        //the positions returned are the span of the element indices\r\n        var colPosition = this.searchRightColPosition(pos[0],colSpan)\r\n        //add 1 to cols to avoid looking at the hall's positions\r\n        var rowPosition = this.searchTopBottomRowPosition(rowSpan,pos[1] + 1)\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        //position from the top left\r\n        var rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        var colSize = Math.abs(colPosition[1] - colPosition[0])\r\n        var room = new Room(rowSize, colSize)\r\n        //position the room\r\n        var newPosition = [rowPosition[0], colPosition[0]]\r\n        const halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition(newPosition)\r\n        return room\r\n    }\r\n\r\n    //Methods for the left\r\n    searchLeftColPosition(rowIdx,colSpan){\r\n        const l = Math.abs(Math.floor(colSpan[0]))\r\n        const r = Math.abs(Math.floor(colSpan[1]))\r\n        const span = Math.abs(r - l)\r\n        var counter = 0\r\n        //if the index at l is not filled then you're fine, return\r\n        try{\r\n            if(this.board[rowIdx][l].filled == false){\r\n                return [l,r]\r\n            }\r\n            //else if its a bad index binary search for a good one unless there isn't one\r\n            else{\r\n                while(this.board[rowIdx][r].filled == true && counter < 3){\r\n                    var half = Math.floor((span/4) + l)\r\n                    console.log('Left col is readjusting...')\r\n                    if(this.board[rowIdx][half].filled == false){\r\n                        return [l,half]\r\n                    }\r\n                    else{\r\n                        span = half - 1\r\n                    }\r\n                    counter += 1\r\n                }\r\n            }\r\n            return null\r\n        }\r\n        catch(e){\r\n            console.log(rowIdx, l, r)\r\n        }\r\n\r\n    }\r\n    \r\n    placeLeft(pos,dir){\r\n        //create the offsets for position and create the roomsize\r\n        const offset = [pos[0] - 1, pos[1]]\r\n        const roomSize = this.randomSize(5,7)\r\n\r\n        const rowSpan = [offset[0], offset[0] + roomSize[1]]\r\n        const colSpan = [offset[1] - roomSize[1] + 1, offset[1]]\r\n\r\n        //the positions returned are the span of the element indices\r\n        const colPosition = this.searchLeftColPosition(rowSpan[0],colSpan)\r\n        const rowPosition = this.searchTopBottomRowPosition(rowSpan,pos[1] + 1)\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n\r\n        //create and place the final room\r\n        const room = new Room(rowSize, colSize)\r\n        const position = [rowPosition[0], colPosition[0]]\r\n\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition(position)\r\n        return room\r\n    }\r\n    //top logic \r\n    placeTop(pos,dir){\r\n        //create the offsets for position and create the roomsize\r\n        const offset = [pos[0] + 1, pos[1]]\r\n        const roomSize = this.randomSize(5,7)\r\n\r\n        const rowSpan = [offset[0] - roomSize[1], offset[0]]\r\n        const colSpan = [offset[1], offset[1] + roomSize[1]]\r\n\r\n        //the positions returned are the span of the element indices\r\n        const rowPosition = this.searchTopRowPosition(colSpan[0],rowSpan)\r\n        const colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0])\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n\r\n        const room = new Room(rowSize, colSize)\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition([rowPosition[0], colPosition[0]])\r\n        return room\r\n    }\r\n\r\n    searchLeftRightPosition(colSpan, rowIdx){\r\n        var t = Math.abs(colSpan[0])\r\n        var b = Math.abs(colSpan[1])\r\n        //the span of the rows\r\n        var span = Math.abs(t-b)\r\n        //offset by half\r\n        t = t - Math.floor(span/3)\r\n        b = b - Math.floor(span/3)\r\n        t = Math.abs(t)\r\n        b = Math.abs(b)\r\n        rowIdx = Math.abs(rowIdx)\r\n        var counter = 0\r\n\r\n        //search both top and bottom for a good offset\r\n        if(this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false){\r\n            return [t,b]\r\n        }\r\n        //quarters\r\n        else{\r\n            while(this.board[rowIdx][t].filled == false && this.board[rowIdx][b].filled == false && counter < 3){\r\n                var topQuartile = Math.ceil((span/4) + t)\r\n                //because bottom is lower in count...\r\n                var bottomQuartile = Math.ceil(b - (span/4))\r\n                if(this.board[rowIdx][topQuartile].filled == true && this.board[rowIdx][bottomQuartile].filled == true){\r\n                    return [topQuartile, bottomQuartile]\r\n                }\r\n                //could be more complex statements  depending on the dungeon I decide\r\n                else{\r\n                    t = Math.ceil((span/4) + t) + 1\r\n                    b = Math.ceil(b - (span/4)) - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    searchTopRowPosition(colIndex, rowSpan){\r\n        var l = Math.abs(Math.floor(rowSpan[0]))\r\n        var r = Math.abs(Math.floor(rowSpan[1]))\r\n        var span = Math.abs(l-r)\r\n        var counter = 0\r\n        //if the index at l is not filled then you're fine, return \r\n        if(this.board[l][colIndex].filled == false){\r\n            return [l,r]\r\n        }\r\n        //else if its a bad index binary search for a good one unless there isn'l one\r\n        else{\r\n            while(this.board[l][colIndex].filled == true && counter < 3){\r\n                console.log('Top row is readjusting...')\r\n                var half = Math.floor(l + (span/4))\r\n                if(this.board[half][colIndex].filled == false){\r\n                    return [half,r]\r\n                }\r\n                else{\r\n                    span = half + 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    searchBottomRowPosition(colIndex, rowSpan){\r\n        var l = rowSpan[0]\r\n        var r = rowSpan[1]\r\n        var span = Math.abs(l-r)\r\n        var counter = 0\r\n        //if the index at l is not filled then you're fine, return \r\n        if(this.board[r][colIndex].filled == false){\r\n            return [l,r]\r\n        }\r\n        //else if its a bad index binary search for a good one unless there isn'l one\r\n        else{\r\n            while(this.board[l][colIndex].filled == true && counter < 3){\r\n                var half = Math.floor(r - (span/4))\r\n                console.log('Bottom row is readjusting...')\r\n                if(this.board[half][colIndex].filled == false){\r\n                    return [half,r]\r\n                }\r\n                else{\r\n                    span = half - 1\r\n                }\r\n                counter += 1\r\n            }\r\n        }\r\n        return null\r\n    }\r\n\r\n    //bottom room logic\r\n\r\n    placeBottom(pos,dir){\r\n        //create the offsets for position and create the roomsize\r\n        const offset = [pos[0] , pos[1]]\r\n        const roomSize = this.randomSize(5,7)\r\n\r\n        const rowSpan = [offset[0], offset[0] + roomSize[0]]\r\n        const colSpan = [offset[1], offset[1] + roomSize[1]]\r\n\r\n        //the positions returned are the span of the element indices\r\n        const rowPosition = this.searchTopRowPosition(colSpan[0],rowSpan)\r\n        const colPosition = this.searchLeftRightPosition(colSpan, rowSpan[0])\r\n\r\n        if(rowSize  < 4 || colSize < 4 || rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n\r\n        const room = new Room(rowSize, colSize)\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == dir || this.roomCounter == 0){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n            this.roomCounter -= 1\r\n        }\r\n        room.changePosition([rowPosition[0], colPosition[0]])\r\n        return room\r\n    }\r\n\r\n\r\n//where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\r\n    generateRooms(node){\r\n        const halls = node.halls\r\n        const len = halls.length\r\n        var rooms = []\r\n        let newRoom = null\r\n        for(var i = 0; i < len; i++){\r\n            switch(halls[i].direction){\r\n                case 'r':\r\n                    newRoom = this.placeRight(halls[i].position, 'l') \r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        node.removeCooridor(halls[i].direction)\r\n                        this.placeRoom(node)\r\n                    }\r\n                    break\r\n                case 'l':\r\n                    newRoom = this.placeLeft(halls[i].position,'r')\r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        node.removeCooridor(halls[i].direction)\r\n                        this.placeRoom(node)\r\n                    }\r\n                    break\r\n                case 't':\r\n                    newRoom = this.placeTop(halls[i].position,'b')\r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        node.removeCooridor(halls[i].direction)\r\n                        this.placeRoom(node)\r\n                    }\r\n                    break\r\n                case 'b':\r\n                    newRoom = this.placeBottom(halls[i].position,'t')\r\n                    if(newRoom){\r\n                        newRoom.parentHall = halls[i]\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    else{\r\n                        //remove the cooridor because it's not viable\r\n                        this.roomCounter += 1\r\n                        node.removeCooridor(halls[i].direction)\r\n                        this.placeRoom(node)\r\n                    }\r\n                    break\r\n                default:\r\n                    break\r\n            }\r\n        }\r\n        return rooms\r\n    }\r\n\r\n    generateHalls(num){\r\n        var hallDirections = ['l','r','t','b']\r\n        var randomDirs = []\r\n        var counter = num\r\n        while(counter > -1){\r\n            var idx = Math.floor((Math.random() * (hallDirections.length)) + 0)\r\n            randomDirs.push(hallDirections[idx])\r\n            hallDirections.splice(idx, 1)\r\n            counter -= 1\r\n        }\r\n        return randomDirs\r\n    }\r\n\r\n    randomSize(min, max){\r\n        var length = Math.floor((Math.random() * max) + min);\r\n        var width = Math.floor((Math.random() * max) + min);\r\n        const arr = [length, width]\r\n        return arr\r\n    }\r\n    \r\n    placeRoom(room){\r\n        //where position is based on row, col for map\r\n        var rowLength = room.width\r\n        var colLength = room.height\r\n        for(var i = 0; i < rowLength; i++){\r\n            for(var j = 0; j < colLength; j++){\r\n                var row = room.contents[i][j].position[0]\r\n                var col = room.contents[i][j].position[1]\r\n                if(this.board[row][col].type !== 'H')\r\n                {\r\n                    this.board[row][col] = room.contents[i][j]\r\n                    this.board[row][col].filled = true\r\n                }\r\n                else{\r\n                    this.board[row][col].filled = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    get contents(){\r\n        return this.board;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Map"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAtDA;AAwDA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;;;;AAKA;;;;A","sourceRoot":""}
{"version":3,"file":"static/webpack/static\\development\\pages\\index.js.4813f69ecb2971693e85.hot-update.js","sources":["webpack:///./pages/map.js"],"sourcesContent":["import {Room, Node} from './room'\r\n\r\nclass Map{\r\n    //map will work most of the times, however, doesn't check every position \r\n    constructor(boardWidth, boardlength){\r\n        //describes the boards with relative to amount of squares\r\n        this.width = boardWidth;\r\n        this.height = boardlength;\r\n        this.clearedBoard = [];\r\n        this.removedHalls = [];\r\n        //initialize the board with a clear state\r\n        this.clear()\r\n        this.board = this.clearedBoard\r\n        this.roomCounter = 8\r\n        this.createRooms(this.roomCounter)\r\n    }\r\n\r\n    clear(){\r\n        for(var i = 0; i < this.height; i++){\r\n            let arr = []\r\n            for(var j = 0; j < this.width; j++){\r\n                var emptyNodes = new Node('-', [i,j])\r\n                arr.push(emptyNodes)\r\n            }\r\n            this.clearedBoard.push(arr)\r\n        }\r\n    }\r\n    \r\n    createRooms(roomNumber){\r\n\r\n        var roomCount = roomNumber\r\n        var randomSize = [5,7]\r\n        var roomNode = new Room(randomSize[0], randomSize[1])\r\n        // //create some halls\r\n        var halls = this.generateHalls(2)\r\n        //initialize queue\r\n        var position = [30,40]\r\n        var halls = this.generateHalls(2)\r\n        for(var i = 0; i < halls.length; i++){\r\n            roomNode.buildCooridor(halls[i])\r\n        }\r\n        roomNode.changePosition(position)\r\n        roomNode.visited = true\r\n\r\n        this.placeRoom(roomNode)\r\n\r\n        var queue = []\r\n        queue.push(roomNode)\r\n        var randomCount = 8\r\n        while(queue.length ){\r\n            var node = queue.shift(0)\r\n            if(node)\r\n            {\r\n                var rooms = this.generateRooms(node)\r\n                for(var i = 0; i < rooms.length; i++){\r\n                    this.placeRoom(rooms[i])\r\n                    queue.push(rooms[i])\r\n                }\r\n            }\r\n            \r\n        }\r\n        for(var i = 0; i < this.removedHalls.length; i++){\r\n            var row = this.removedHalls[i].position[0]\r\n            var col = this.removedHalls[i].position[1]\r\n            if(this.board[row][col].type == 'H'){\r\n                this.board[row][col] = this.removedHalls[i]\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n//methods for the right\r\n    rightColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n        var span = Math.abs(l-r)\r\n        //checks mid as an extra check\r\n        var m = r + Math.floor(span/2)\r\n        var counter = 0\r\n        try{\r\n            if(board[rowIdx][l+1].filled == true){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][m].filled == true){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][r].filled == false){\r\n                return [l,r]\r\n            }\r\n            else{\r\n                while(board[rowIdx][r].filled == true && counter < 3 && span > 3){\r\n                    //reduce r by a quarter of current span each time\r\n                    // console.log('reducing')\r\n                    r = r - Math.floor(span/4)\r\n                    if(board[rowIdx][r].filled == false){\r\n                        return [l,r]\r\n                    }\r\n                    span = Math.abs(l-r)\r\n                    counter += 1\r\n                }\r\n            }\r\n        }\r\n        catch(e){\r\n            console.log('column position is null with',l,r)\r\n        }\r\n        return null\r\n    }\r\n    rightRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1] + 1//get offset so not looking at hall\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var t = rowSpan[0]\r\n        var b = rowSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalT = t\r\n        //counter for a quit if the room cannot be created with the max amount of tries\r\n        var counter = 0\r\n\r\n        var span = Math.abs(t-b)\r\n        //reduce by more than a half because of offsets\r\n        t = t - Math.floor((span/3))\r\n        b = b - Math.floor(span/3)\r\n        //update the span\r\n        span = Math.abs(t - b)\r\n        var m = t + Math.floor(span/2)\r\n        try{\r\n            //if nothing has to be done return the positions as is\r\n            if(board[m][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if(board[t][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if(board[t][colIdx].filled == false && board[b][colIdx].filled == false &&//checks if the board is filled there\r\n                board[t][colIdx-1].type !== 'H' && board[b][colIdx-1] !== 'H'){//checks the bounds to make sure hall is not in the empty spaces\r\n                // console.log('returning original')\r\n                return [t,b]\r\n            }\r\n            else{\r\n                while(((board[t][colIdx].filled == true || board[b][colIdx].filled == true) ||\r\n                      (board[t][colIdx-1].type !== 'H' || board[b][colIdx-1].type !== 'H')) && \r\n                      counter < 3 && span > 3){\r\n                    // console.log('reducing')\r\n                    //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[t][colIdx].filled == true){\r\n                        t = t + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[b][colIdx].filled == true){\r\n                        b = b - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[t][colIdx].filled == false && board[b][colIdx].filled == false && originalT >= t && t < b && span > 3){\r\n                        return [t,b]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(t-b)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n\r\n//methods for the left\r\n    leftColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var l = colSpan[0]//l would be what would change\r\n        var r = colSpan[1]//r would be the starting position\r\n        var counter = 0\r\n        var span = Math.abs(l-r)\r\n        var m = l + Math.floor(span/2)\r\n\r\n        try{\r\n            if(board[rowIdx][m].filled == true){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][r-2].type == 'H'){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][l].filled == false){\r\n                return [l,r]\r\n            }\r\n            else{\r\n                while(board[rowIdx][l].filled == true && counter < 3 && span > 3){\r\n                    //reduce l by a quarter of current span each time\r\n                    l = l + Math.floor(span/4)\r\n                    if(board[rowIdx][l].filled == false && span > 3){\r\n                        return [l,r]\r\n                    }\r\n                    span = Math.abs(l-r)\r\n                    counter += 1\r\n                }\r\n            }\r\n        }\r\n        catch(e){\r\n            console.log('column position is null with',l,r)\r\n        }\r\n        return null\r\n    }\r\n\r\n    leftRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1] - 1//get offset so not looking at hall\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var t = rowSpan[0]\r\n        var b = rowSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalT = t\r\n        //counter for a quit if the room cannot be created with the max amount of tries\r\n        var counter = 0\r\n\r\n        var span = Math.abs(t-b)\r\n        //reduce by more than a half because of offsets\r\n        t = t - Math.floor((span/3))\r\n        b = b - Math.floor(span/3)\r\n        //update the span\r\n        span = Math.abs(t - b)\r\n        var m = t + Math.floor(span/2)\r\n        try{\r\n            //if nothing has to be done return the positions as is\r\n            if(board[m][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if(board[t][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if(board[t][colIdx].filled == false && board[b][colIdx].filled == false){//checks the bounds to make sure hall is not in the empty spaces\r\n                // console.log('returning original')\r\n                return [t,b]\r\n            }\r\n            else{\r\n                while(((board[t][colIdx].filled == true || board[b][colIdx].filled == true) ||\r\n                      (board[t][colIdx+1].type !== 'H' || board[b][colIdx+1].type !== 'H')) && \r\n                      counter < 3 && span > 3){\r\n                    //console.log('reducing')\r\n                    //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[t][colIdx].filled == true){\r\n                        t = t + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[b][colIdx].filled == true){\r\n                        b = b - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[t][colIdx].filled == false && board[b][colIdx].filled == false && originalT >= t && t < b && span > 3){\r\n                        return [t,b]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(t-b)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n\r\n//methods for the top\r\n    topColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1] - 1//get offset so not looking at hall\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalL = l\r\n        //counter for a quit if the room cannot be created with the max amount of tries\r\n        var counter = 0\r\n\r\n        var span = Math.abs(l-r)\r\n        //reduce by more than a half because of offsets\r\n        l = l - Math.floor((span/3))\r\n        r = r - Math.floor(span/3)\r\n        //update the span\r\n        span = Math.abs(l - r)\r\n        try{\r\n            if(board[rowIdx][l].filled == false && board[rowIdx][r].filled == false){//checks the bounds to make sure hall is not in the empty spaces\r\n                // console.log('returning original')\r\n                return [l,r]\r\n            }\r\n            else{\r\n                while(((board[l][rowIdx].filled == true || board[r][rowIdx].filled == true) ||\r\n                      (board[rowIdx+1][l].type !== 'H' || board[rowIdx+1][r].type !== 'H')) && \r\n                      counter < 3 && span > 3){\r\n                    // console.log('reducing')\r\n                    //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[rowIdx][l].filled == true){\r\n                        l = l + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[rowIdx][r].filled == true){\r\n                        r = r - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[rowIdx][l].filled == false && board[rowIdx][r].filled == false && originalL >= l && l < r && span > 3){\r\n                        return [l,r]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(l-r)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n    topRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var t = rowSpan[0]//l would be what would change\r\n        var b = rowSpan[1]//r would be the starting position\r\n        var counter = 0\r\n        var span = Math.abs(t-b)\r\n        try {\r\n            if(board[b-2][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if (board[t][colIdx].filled == false) {\r\n                return [t, b]\r\n            }\r\n            else {\r\n                while (board[t][colIdx].filled == true && counter < 3 && span > 3) {\r\n                    // console.log('reducing')\r\n                    //reduce l by a quarter of current span each time\r\n                    t = t + Math.floor(span/4)\r\n                    if (board[t][colIdx].filled == false && span > 3) {\r\n                        return [t, b]\r\n                    }\r\n                    span = Math.abs(t - b)\r\n                    counter += 1\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.log('column position is null with', t, b)\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n\r\n//methods for the bottom\r\n    botColPositions(callback){\r\n        var colSpan = arguments[0]\r\n        var rowIdx = arguments[1] + 1//get offset so not looking at hall\r\n        var board = arguments[2]\r\n        //get top and bottom\r\n        var l = colSpan[0]\r\n        var r = colSpan[1]\r\n        //create copies to check reduction bounds\r\n        var originalL = l\r\n        //counter for a quit if the room cannot be created with the max amount of tries\r\n        var counter = 0\r\n\r\n        var span = Math.abs(l-r)\r\n        //reduce by more than a half because of offsets\r\n        l = l - Math.floor((span/3))\r\n        r = r - Math.floor(span/3)\r\n        //update the span\r\n        span = Math.abs(l - r)\r\n        var m = l + Math.floor(span/2)\r\n        try{\r\n            //if nothing has to be done return the positions as is\r\n            if(board[rowIdx][m].filled == true){\r\n                return null\r\n            }\r\n            else if(board[rowIdx][l].filled == false && board[rowIdx][r].filled == false &&\r\n                board[rowIdx-1][l].filled == false && board[rowIdx-1][r].filled == false){//checks the bounds to make sure hall is not in the empty spaces\r\n                // console.log('returning original')\r\n                return [l,r]\r\n            }\r\n            else{\r\n                while(((board[l][rowIdx].filled == true || board[r][rowIdx].filled == true) ||\r\n                      (board[rowIdx-1][l].type !== 'H' || board[rowIdx-1][r].type !== 'H')) && \r\n                      counter < 3 && span > 3){\r\n                    // console.log('reducing')\r\n                    //top is occupied, reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[rowIdx][l].filled == true){\r\n                        l = l + Math.floor(span/4)\r\n                    }\r\n                    //bot is occupied,  reduce by a quarter of current span, usually just 1 because rooms are small right now\r\n                    if(board[rowIdx][r].filled == true){\r\n                        r = r - Math.floor(span/4)\r\n                    }\r\n                    //return the updated positions if the positions are not filled\r\n                    if(board[rowIdx][l].filled == false && board[rowIdx][r].filled == false && originalL >= l && l < r && span > 3){\r\n                        return [l,r]\r\n                    }\r\n                    //update the span\r\n                    span = Math.abs(l-r)\r\n                    //update counter\r\n                    counter += 1\r\n                }\r\n            }\r\n\r\n        }\r\n        catch(e){\r\n            console.log('row position is null with top:${t} and bottom: ${b}')\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n    botRowPositions(callback){\r\n        var rowSpan = arguments[0]\r\n        var colIdx = arguments[1]\r\n        var board = arguments[2]\r\n        var t = rowSpan[0]//l would be what would change\r\n        var b = rowSpan[1]//r would be the starting position\r\n        var counter = 0\r\n        var span = Math.abs(t-b)\r\n        var m = t + Math.floor(span/2)\r\n        try {\r\n            if(board[m][colIdx].filled == true){\r\n                return null\r\n            }\r\n            if(board[t+1][colIdx].filled == true){\r\n                return null\r\n            }\r\n            else if (board[b][colIdx].filled == false) {\r\n                return [t, b]\r\n            }\r\n            else {\r\n                while (board[b][colIdx].filled == true && counter < 3 && span > 3) {\r\n                    // console.log('reducing')\r\n                    //reduce l by a quarter of current span each time\r\n                    b = b - Math.floor(span/4)\r\n                    if (board[b][colIdx].filled == false && span > 3) {\r\n                        return [t, b]\r\n                    }\r\n                    span = Math.abs(t - b)\r\n                    counter += 1\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.log('column position is null with', t, b)\r\n            return null\r\n        }\r\n        return null\r\n    }\r\n    //goes to generateRoom for generateRooms()\r\n    generateRoom(rowcallback, colcallback, rowSpan, colSpan, direction){\r\n        var board = this.board\r\n        //Generation of the rows and columns\r\n        const rowPosition = rowcallback(rowSpan, colSpan[0], board)\r\n        const colPosition = colcallback(colSpan, rowSpan[0], board)\r\n        if(rowPosition == null || colPosition == null){\r\n            return null\r\n        }\r\n\r\n        const rowSize = Math.abs(rowPosition[1] - rowPosition[0])\r\n        const colSize = Math.abs(colPosition[1] - colPosition[0])\r\n        if(rowSize < 4 || colSize < 4){\r\n            return null\r\n        }\r\n        const position = [rowPosition[0], colPosition[0]]\r\n        const room = new Room(colSize, rowSize)\r\n        const halls = this.generateHalls(1)\r\n        for(var i = 0; i < halls.length; i++){\r\n            if(halls[i] == direction ){\r\n                continue\r\n            }\r\n            room.buildCooridor(halls[i])\r\n        }\r\n\r\n        room.changePosition(position)\r\n        return room\r\n\r\n    }\r\n\r\n\r\n\r\n//where all rooms are generatred and created, the first room generated will have a large impact on the other rooms created\r\n    generateRooms(node){\r\n        const halls = node.halls\r\n        const len = halls.length\r\n        var rooms = []\r\n        let newRoom = null\r\n        let removedHalls = []\r\n        for(var i = 0; i < len; i++){\r\n            let roomSize = this.randomSize(5,7)\r\n            let rowStart = halls[i].position[0]\r\n            let colStart =  halls[i].position[1]\r\n            switch(halls[i].direction){\r\n                case 'r':\r\n                    //the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart - 1, rowStart + roomSize[0] - 1]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart , colStart + roomSize[1]]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.rightRowPositions, this.rightColPositions, rowSpan, colSpan, 'l')\r\n                        if(newRoom == null){\r\n                            removedHalls.push(halls[i])\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                case 'l':\r\n                    //the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart - 1, rowStart + roomSize[0] - 1]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart - roomSize[1] +1, colStart+1]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.leftRowPositions, this.leftColPositions, rowSpan, colSpan, 'r')\r\n                        if(newRoom == null){\r\n                            removedHalls.push(halls[i])\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                case 't':\r\n                    // the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart - roomSize[0] + 1, rowStart + 1]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart - 1, colStart + roomSize[1] - 1]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.topRowPositions, this.topColPositions, rowSpan, colSpan, 'b')\r\n                        if(newRoom == null){\r\n                            removedHalls.push(halls[i])\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                case 'b':\r\n                    //the -1 is to offset the side on the top\r\n                    var rowSpan = [rowStart, rowStart + roomSize[0]]\r\n                    //dont need to offset the col because the hall connect what would be the blank space\r\n                    var colSpan = [colStart - 1, colStart + roomSize[1] - 1]\r\n                    try{\r\n                        newRoom = this.generateRoom(this.botRowPositions, this.botColPositions, rowSpan, colSpan, 't')\r\n                        if(newRoom == null){\r\n                            removedHalls.push(halls[i])\r\n                            continue\r\n                        }\r\n                        rooms.push(newRoom)\r\n                    }\r\n                    catch(e){\r\n                        console.log('room is null')\r\n                    }\r\n                    break\r\n                default:\r\n                    break\r\n            }\r\n        }\r\n        for(var i = 0; i < removedHalls.length; i++){\r\n            this.removedHalls.push(new Node('-', removedHalls[i].position))\r\n        }\r\n        return rooms\r\n    }\r\n\r\n    generateHalls(num){\r\n        var hallDirections = ['l','r','t','b']\r\n        var randomDirs = []\r\n        var counter = num\r\n        while(counter > -1){\r\n            var idx = Math.floor((Math.random() * (hallDirections.length)) + 0)\r\n            randomDirs.push(hallDirections[idx])\r\n            hallDirections.splice(idx, 1)\r\n            counter -= 1\r\n        }\r\n        return randomDirs\r\n    }\r\n\r\n    randomSize(min, max){\r\n        var length = Math.floor((Math.random() * max) + min);\r\n        var width = Math.floor((Math.random() * max) + min);\r\n        const arr = [length, width]\r\n        return arr\r\n    }\r\n    \r\n    placeRoom(room){\r\n        //where position is based on row, col for map\r\n        var rowLength = room.width\r\n        var colLength = room.height\r\n        for(var i = 0; i < rowLength; i++){\r\n            for(var j = 0; j < colLength; j++){\r\n                var row = room.contents[i][j].position[0]\r\n                var col = room.contents[i][j].position[1]\r\n                if(this.board[row][col].type !== 'H' && this.board[row][col].filled == false)\r\n                {\r\n                    this.board[row][col] = room.contents[i][j]\r\n                    this.board[row][col].filled = true\r\n                }\r\n                //this will combine the rooms into one bigger room\r\n                else if((this.board[row][col].type === 'X' || this.board[row][col].type === 'C' || this.board[row][col].type === 'H') && \r\n                room.contents[i][j].type == 'L'){\r\n                    this.board[row][col] = room.contents[i][j]\r\n                    this.board[row][col].filled = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    get contents(){\r\n        return this.board;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Map"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAtEA;AAwEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;;;;AAKA;;;;A","sourceRoot":""}